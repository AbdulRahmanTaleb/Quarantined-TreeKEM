# MLS (Messaging Layer Security) with Quarantined-TreeKEM

This repository contains an implementation the Quarantined-TreeKEM feature for the MLS protocol from the paper [Quarantined-TreeKEM: a Continuous Group Key Agreement for MLS, Secure in Presence of Inactive Users](https://eprint.iacr.org/2023/1903). It is based on a fork of the [MLS protocol implementation in kotlin](https://github.com/Traderjoe95/mls-kotlin).

In the following, we state the main modifications that were done to the original MLS code.

We added examples and tests related to the quarantine procedure in the `demo` module. The related test files are named `QuarantinedTestScenarioN` where `N` is replaced by a number.

All of the modified files are in the `protocol` module. The most relevant code to the quarantine procedure is in the file `protocol.group.Commit.kt` which contains the methods:
- `prepareCommit` called by the committer to create the commit message
- `processCommit` called by other group members that receive the commit message

As described in the [Quarantined-TreeKEM](https://eprint.iacr.org/2023/1903) paper, a committer checks when creating the commit message:
- if a user was inactive long enough to be turned into a ghost user
- if the ghost keys of a ghost user needs to be updated
- if a ghost user was inactive long enough to be deleted from the group.

This is done in the `updateGhostMembers` method called from the `prepareCommit` method. For this purpose, each LeafNode (`protocol.types.tree.LeafNode.kt`) holds:
- `epk`: a variable which stores the epoch number where the keys of the user were last updated.
- `equar`: a variable which stores the epoch where the user was turned into a ghost.

The committer compares these variables for each LeafNode, to the parameters stored in the GroupState (`protocol.group.GroupState.kt`):

- `INACTIVITY_DELAY`: the maximum number of epochs for a user to not update its keys before being turned into a ghost
- `UPDATE_QUARANTINE_KEYS_DELAY`: the frequency at which ghost user keys must be updated during its quarantine
- `DELETE_FROM_QUARANTINE_DELAY`: the maximum number of epochs for a user to stay a ghost before being deleted from the group.

A `GroupState` holds an additional field called `GroupGhostInfo` (`protocol.group.GroupGhostInfo.kt`) which stores:
- a list of the current ghost members. Each ghost member is represented by a `GhostMember` containing:
   - the `LeafIndex` of the ghost node
   - a list of the ghost encryptions keys with the epoch where the key was generated.
- a list of the shares of the encryption keys for each ghost that this user holds. Each such share is stored in a `GhostShareHolder` containing:
   - the ghost public encryption key associated to the secret key for which this share is generated
   - the ghost `LeafIndex`
   - the ghost secret share (`protocol.crypto.secret_sharing.ShamirSecretSharing.SecretShare`)
   - the rank of the user holding this share among the other users holding the same share

In the ratchet tree, a ghost leaf node is represented by a `LeafNode` (`protocol.types.tree.LeafNode`) with:
- the `source` set to `LeafNodeSource.Ghost`
- the `info` set to `null`
- the `signature` set to a 1-byte zero.

It is set as such since a ghost `LeafNode` is not created by the ghost user itself, but by the committer. The committer does not hold the signature key of the ghost user, but has to update the ratchet tree to mark this user as a ghost. For these reasons, the corresponding `LeafNode` is updated by updating the source of the node to `LeafNodeSource.Ghost` and updating the public encryption key with the new one generated by the committer, and ignoring the signature field of the newly marked ghost leaf node.

### 1. Creating, Updating & Deleting Ghost Users

#### 1.1) Preparing a commit 

When a client wants to commit (by calling commit from `protocol.client.GroupClient.kt`), it calls the `prepareCommit()` method from its `GroupState`. The method first starts by processing the stored proposals (`processProposals()`), then calls `updateGhostMembers()` which:
- identifies the ghost members that need to be deleted
- identifies the users that must be transformed into ghosts, in which case a new random `secret` (`protocol.types.crypto.Secret`) is generated for each such user 
- identifies the ghost users for which encryption keys must be renewed, in which case a new random `secret` is generated for each such user.

In the case of a ghost user deletion, the user is removed from the ratchet tree, and the list of ghost users' `LeafIndex` is attached to the commit message (`protocol.types.framing.content.Commit`) so that the other users in the group can do the same verification and delete the same users from the tree. Note that since all users have access to the `epk` and `equar` fields of the ghosts' leaf nodes, they can automatically check which ghost users must be deleted. The committer sending the list of ghost users to deleted is hence not mandatory but added for validation.

In the case of a `secret` generated, the latter is used to generate the new encryption keys for the ghost user and hence update the ghost LeafNode with the new public key. Each such new generated key is joined to the commit message in a `GhostMemberCommit` (`group.GhostMemberCommit`) data object containing:
- the leaf index of the ghost user (the new ghost user or the one for which the encryption keys were updated)
- the new ghost encryption key
- this epoch number marking when the encryption key is updated

The `GhostMemberCommit` is generated by calling `GroupGhostInfo.addNewGhostMember` or `GroupGhostInfo.addNewGhostKey` which also updates the `GroupGhostInfo` in the group state.

When any of the three above cases is executed, an `UpdatePath` (`protocol.types.tree.UpdatePath`) becomes necessary in the commit message. The `UpdatePath` is generated in the `createUpdatePath` method (in the file `protocol.tree.TreeUpdate.kt`) called from `prepareCommit()`.   For each `secret` generated for a ghost user, the latter is split into $n$ shares using the `ShamirSecretSharing.generateShares()` method. The number of shares is determined using the default share distribution method if the number of nodes on the filtered direct path is not lower than the minimum number of shares allowed ( `MINIMUM_SECRET_SHARING_NB` defined in `protocol.group.GroupState`). Otherwise, the horizontal share distribution method is used. 

In both cases, the shares are encrypted and joined to the `UpdatePath` as a list of `GhostShareDistribution` data objects. In the case of the default share distribution method, each GhostShareDistribution corresponds to a node on the filtered direct path and holds:
- the public encryption key of the node on the filtered direct path
- the encrypted corresponding share using the public key of each node in the resolution of the  child of this node on the co-path of the committer (in other words, similarly to how `UpdatePathNode` is created). Thus, this is represented as a list of encrypted shares. The rank of share holder is determined from left to right.

In the case of the horizontal share distribution method, each `GhostShareDistribution` corresponds to a node on the chosen level of the method, containing its public encryption key, and the corresponding encrypted share using this public key. In this case, there is a single encrypted share for each `GhostShareDistribution`, unlike the case of the default share distribution method where a `GhostShareDistribution` can hold more than one encryption of the same share, depending on the number of nodes in the resolution. 


#### 1.2) Processing a commit 

When a user processes a commit, they call the `processCommit()` method. The processing of the ghost users happends in the `processGhostMembers()` method, analogously to the `updateGhostMembers()` method. In other words, the user deletes the ghost users that are set to be deleted in the received commit message, then for each `GhostMemberCommit` in the commit message, the user updates the corresponding LeafNode with the new encryption keys and sets its source to `LeafNodeSource.Ghost` if this is a new ghost LeafNode.

Then, the user looks for encrypted shares that are destined to them by calling `applyCommitUpdatePath`. They either look for shares encrypted using the default share distribution method, or the horizontal share distribution method, depending on which method was used during the commit.

### 2. Ending a Quarantine

When a ghost user reconnects, they send an `QuarantineEndMessage` to the other users signaling their reconnection, constructed using `protocol.client.ActiveGroupClient#endQuarantine()` method. This message contains the new LeafNode of the user where they update their encryption keys and changes the `LeafNodeSource` to `Update` instead of `Ghost`. At this point, the user can rejoin the group but cannot decrypt messages exchanged during their ghost period since their encryption keys were generated by the committers.

Each user that receives `QuarantineEndMessage` checks whether they have secret shares for ghost encryption keys of this user (using the `protocol.client.ActiveGroupClient#processQuarantineEnd()` method), for which they are share holder of rank 1, in this case, they send the corresponding shares to the reconnecting user in a `ShareRecoveryMessage`.

The ghost user can retrieve the current state of the group with one of the two following options:
- ask for a `WelcomeBackGhostMessage` at the next commit as described further in this section
- start by reconstructing all of their ghost encryption keys and decryption cached conversations to update their view of the group (c.f. Section 3)

The user has the option since sending a complete view of the ratchet tree can be expensive for large groups. Hence the `WelcomeBackGhostMessage` is only sent if the ghost user asks for it, in the case where they are not able to recover their encryption keys immediately and need to join the group anyway. In this case, the ghost user sends a `RequestWelcomeBackGhostMessage` message (`protocol.message.RequestWelcomeBackGhost`) so that at the next commit, the committer sends a `WelcomeBackGhostMessage`.

When the next user commits, they create a `WelcomeBackGhostMessage` (`protocol.group.PrepareCommitResult.WelcomeBackGhostMessage`) destined to be sent to the reconnecting user. This message essentially contains the root keys and the ratchet tree for the next epoch, so that the reconnecting user can join the group, without having to decrypt previous conversations (in case they did not recover all the secret shares from other users yet). More precisely, the `protocol.message.WelcomeBackGhost` data object contained in the `WelcomeBackGhostMessage` has essentially the fields:
- encrypted `GroupInfo` of the current group, with the current status of the public ratchet tree, enabling the ghost user to sync their view of the group
- encrypted root secrets of the ratchet tree so that the ghost user can participate in future conversations, without having to recover their ghost encryption keys.

When the concerned user receives the `WelcomeBackGhostMessage`, they update their group state by calling the `protocol.client.ActiveGroupClient#processWelcomeBackGhostMessage()` method.

### 3. Recovering Previous Ghost Encryption Keys

If a ghost user that successfully reconnected, was not able to recover all secret shares necessary for them to decrypt previous conversations, they can ask for other shares with share holder ranks greater than 1, by sending a `MlsShareResendMessage` (`protocol.client.ActiveGroupClient#shareResend()`). This message contains the share holder rank for which users should send the shares they have. The share holder rank corresponds to the successor of the last one received by the user. For instance, when ending a quarantine, the user receives shares from users with share holder rank = 1, then the user can send a ShareResend Message for share holder rank = 2, etc., until they are able to reconstruct all of the ghost encryption keys during their inactivity period. The users receiving this ShareResendMessage can then send a `ShareRecoveryMessage` if they have shares for the concerned user with the appropriate share holder rank.

Once the user recovered all the necessary shares, they can start reconstructing the encryption keys and decrypting previous conversations. The recovery process starts with `protocol.client.ActiveGroupClient#startGhostMessageRecovery()` and ends with `protocol.client.ActiveGroupClient#endGhostMessageRecovery()`. An example is illustrated in the test files, where the method `demo.client.Client#processCachedGhostMessages()` is called to decrypted the cached messages.

<br />

# Original README from mls-kotlin repository

The following is the content of the original README from the github repository: https://github.com/Traderjoe95/mls-kotlin

An Implementation of the [MLS (Messaging Layer Security) Standard (RFC 9420)](https://www.rfc-editor.org/rfc/rfc9420.html)
in Kotlin.

## What is MLS?

MLS is a standard to facilitate end-to-end-encrypted messaging applications, by employing a tree-based group key
management protocol that is designed to provide Perfect Forward Secrecy (PFS) and Post-Compromise Security (PCS).
The standard focuses on efficient group operations, making it suitable to serve group chats of up to multiple thousand
members.

Changes to the group state are carried out in so-called _epochs_, each of which is initiated by a _commit_, which
applies one or more change _proposals_ to the group state. These proposals may add a member, remove a member or
update a members key material, among others. The protocol ensures that any given client has access to the key material
of the group in any given epoch, if, and only if, the client was a member of the group during this epoch.

The members of the group are organized in a _ratchet tree_, which provides efficient means to encrypt a message for
any subset of the group's members. The ratchet tree is used to seed a _key schedule_, which updates the group's shared
key material for each epoch. From the key schedule, a _secret tree_ having the same structure as the ratchet tree is
derived, which provides a message encryption ratchet for each member of the group. The symmetric keys produced by said
ratchet are then used to protect messages sent in the group.

## This Library

This library provides a fully RFC-compliant Kotlin implementation of the MLS standard. It exposes a low-level API
with detail control about group operations, as well as a convenient high-level API that encapsulates most of the
complexity of the protocol and gives applications only the choices they absolutely need.

The low-level API is centered around the `com.github.traderjoe95.mls.protocol.group.GroupState` type, representing
the state of an MLS group during a single epoch. It is an immutable type, returning a new copy anytime something is
updated, so applications are responsible to keep a history of changes to the group state, if they require so.

The high-level API is provided by the `com.github.traderjoe95.mls.protocol.client.MlsClient` and
`com.github.traderjoe95.mls.protocol.client.GroupClient` classes. A `GroupClient` is a client for a single group
that provides convenient, high-level methods for group evolution. It keeps a history of group states such that
application messages received out of order (e.g. after an epoch change has already taken place) can still be
decrypted. An `MlsClient` is an entity capable of managing multiple group clients, keeping their state and facilitating
special tasks such as group resumption (subgroup branching or reinitialization).

The `demo` module provides a few examples on how the APIs of this library may be used.

### Prerequisites

This library is currently built with

* Kotlin JVM 1.9.22
* Java 21

This is likely to change in the not-too-distant future to ensure further compatibility, and to enable a future move to
Kotlin Multiplatform, in order to make this library available across all or most platforms supported by Kotlin.

### Modules

* `codec` implements the raw MLS codec, that is, as slightly enhanced TLS 1.3 presentation language
* `protocol` provides all MLS struct and enum types, as well as implementations of the MLS protocol
* `interop` provides the MLS test harness for interop testing
* `demo` is a collection of simple examples of library usage.

## Roadmap

Within each section below, the entries are decidedly _not ordered by priority_.

### Short-Term

* Polish high-level API, add missing functionality
* Implement the [MLS Test Harness](https://github.com/mlswg/mls-implementations/blob/main/test-harness.md) to facilitate
  interop testing
* Publishing to Maven Central, or similar
* Add support for the few missing bits from the standard
* Restructure the project
  * Remove the `ulid` module, as it is only used for the demo

### Mid-Term

* API documentation
* Provide a usable Java API
* Increase test coverage of the `protocol` module

### Long-Term

* Kotlin Multiplatform
