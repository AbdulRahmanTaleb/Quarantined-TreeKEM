


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>protocol Coverage Report > PrivateMessage</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: protocol<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.github.traderjoe95.mls.protocol.message</a>
</div>

<h1>Coverage Summary for Class: PrivateMessage (com.github.traderjoe95.mls.protocol.message)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">PrivateMessage</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.7%
  </span>
  <span class="absValue">
    (107/113)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.1%
  </span>
  <span class="absValue">
    (565/582)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PrivateMessage$Companion</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (60/65)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.3%
  </span>
  <span class="absValue">
    (313/332)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PrivateMessage$Companion$create$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">PrivateMessage$encoded$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PrivateMessage$special$$inlined$lift$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">PrivateMessage$special$$inlined$lift$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">PrivateMessage$unprotect$2</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    76.5%
  </span>
  <span class="absValue">
    (13/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (12/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (167/179)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.6%
  </span>
  <span class="absValue">
    (878/918)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.github.traderjoe95.mls.protocol.message
&nbsp;
&nbsp;import arrow.core.Either
&nbsp;import arrow.core.raise.Raise
&nbsp;import arrow.core.raise.either
&nbsp;import com.github.traderjoe95.mls.codec.Encodable
&nbsp;import com.github.traderjoe95.mls.codec.Struct2
&nbsp;import com.github.traderjoe95.mls.codec.Struct3
&nbsp;import com.github.traderjoe95.mls.codec.Struct4
&nbsp;import com.github.traderjoe95.mls.codec.decodeAs
&nbsp;import com.github.traderjoe95.mls.codec.decodeWithPadding
&nbsp;import com.github.traderjoe95.mls.codec.type.DataType
&nbsp;import com.github.traderjoe95.mls.codec.type.V
&nbsp;import com.github.traderjoe95.mls.codec.type.opaque
&nbsp;import com.github.traderjoe95.mls.codec.type.struct.Struct6T
&nbsp;import com.github.traderjoe95.mls.codec.type.struct.lift
&nbsp;import com.github.traderjoe95.mls.codec.type.struct.struct
&nbsp;import com.github.traderjoe95.mls.codec.type.uint32
&nbsp;import com.github.traderjoe95.mls.codec.type.uint64
&nbsp;import com.github.traderjoe95.mls.protocol.crypto.ICipherSuite
&nbsp;import com.github.traderjoe95.mls.protocol.error.DecoderError
&nbsp;import com.github.traderjoe95.mls.protocol.error.MessageSenderError
&nbsp;import com.github.traderjoe95.mls.protocol.error.PrivateMessageRecipientError
&nbsp;import com.github.traderjoe95.mls.protocol.error.PrivateMessageSenderError
&nbsp;import com.github.traderjoe95.mls.protocol.group.GroupContext
&nbsp;import com.github.traderjoe95.mls.protocol.group.GroupState
&nbsp;import com.github.traderjoe95.mls.protocol.message.padding.PaddingStrategy
&nbsp;import com.github.traderjoe95.mls.protocol.message.padding.deterministic.Padme
&nbsp;import com.github.traderjoe95.mls.protocol.tree.LeafIndex
&nbsp;import com.github.traderjoe95.mls.protocol.tree.SecretTree
&nbsp;import com.github.traderjoe95.mls.protocol.tree.SignaturePublicKeyLookup
&nbsp;import com.github.traderjoe95.mls.protocol.types.GroupId
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Aad.Companion.asAad
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Ciphertext
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Mac
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Nonce
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.ReuseGuard
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Secret
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Signature
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.Sender
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.ApplicationData
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.AuthenticatedContent
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Commit
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Content
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.FramedContent
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Proposal
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.enums.ContentType
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.enums.SenderType
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.enums.WireFormat
&nbsp;
<b class="fc">&nbsp;data class PrivateMessage&lt;out C : Content&lt;C&gt;&gt;(</b>
<b class="fc">&nbsp;  override val groupId: GroupId,</b>
<b class="fc">&nbsp;  override val epoch: ULong,</b>
<b class="fc">&nbsp;  override val contentType: ContentType&lt;C&gt;,</b>
<b class="fc">&nbsp;  val authenticatedData: ByteArray,</b>
<b class="fc">&nbsp;  val encryptedSenderData: Ciphertext,</b>
<b class="fc">&nbsp;  val ciphertext: Ciphertext,</b>
&nbsp;) : GroupMessage&lt;C&gt;,
&nbsp;  Struct6T.Shape&lt;GroupId, ULong, ContentType&lt;C&gt;, ByteArray, Ciphertext, Ciphertext&gt; {
<b class="fc">&nbsp;  override val wireFormat: WireFormat = WireFormat.MlsPrivateMessage</b>
&nbsp;
<b class="pc">&nbsp;  override val encoded: ByteArray by lazy { encodeUnsafe() }</b>
&nbsp;
<b class="fc">&nbsp;  constructor(framedContent: FramedContent&lt;C&gt;, encryptedSenderData: Ciphertext, ciphertext: Ciphertext) : this(</b>
<b class="fc">&nbsp;    framedContent.groupId,</b>
<b class="fc">&nbsp;    framedContent.epoch,</b>
<b class="fc">&nbsp;    framedContent.contentType,</b>
<b class="fc">&nbsp;    framedContent.authenticatedData,</b>
<b class="fc">&nbsp;    encryptedSenderData,</b>
<b class="fc">&nbsp;    ciphertext,</b>
&nbsp;  )
&nbsp;
&nbsp;  private fun privateContentAad(): Struct4&lt;GroupId, ULong, ContentType&lt;C&gt;, ByteArray&gt; =
<b class="fc">&nbsp;    Struct4(groupId, epoch, contentType, authenticatedData)</b>
&nbsp;
<b class="fc">&nbsp;  private fun senderDataAad(): Struct3&lt;GroupId, ULong, ContentType&lt;C&gt;&gt; = Struct3(groupId, epoch, contentType)</b>
&nbsp;
&nbsp;  override suspend fun unprotect(groupState: GroupState.Active): Either&lt;PrivateMessageRecipientError, AuthenticatedContent&lt;C&gt;&gt; =
<b class="nc">&nbsp;    unprotect(</b>
<b class="nc">&nbsp;      groupState.groupContext,</b>
<b class="nc">&nbsp;      groupState.keySchedule.senderDataSecret,</b>
<b class="nc">&nbsp;      groupState.secretTree,</b>
<b class="nc">&nbsp;      groupState.tree,</b>
&nbsp;    )
&nbsp;
&nbsp;  suspend fun unprotect(
&nbsp;    groupContext: GroupContext,
&nbsp;    senderDataSecret: Secret,
&nbsp;    secretTree: SecretTree,
&nbsp;    signaturePublicKeyLookup: SignaturePublicKeyLookup,
&nbsp;  ): Either&lt;PrivateMessageRecipientError, AuthenticatedContent&lt;C&gt;&gt; =
<b class="fc">&nbsp;    either {</b>
<b class="fc">&nbsp;      with(groupContext.cipherSuite) {</b>
<b class="fc">&nbsp;        val (senderDataNonce, senderDataKey) = getSenderDataNonceAndKey(this, senderDataSecret, ciphertext)</b>
&nbsp;
<b class="fc">&nbsp;        val senderData =</b>
<b class="fc">&nbsp;          try {</b>
<b class="fc">&nbsp;            DecoderError.wrap {</b>
<b class="fc">&nbsp;              decryptAead(</b>
<b class="fc">&nbsp;                senderDataKey,</b>
<b class="fc">&nbsp;                senderDataNonce,</b>
<b class="fc">&nbsp;                SENDER_DATA_AAD_T.encodeUnsafe(senderDataAad()).asAad,</b>
<b class="fc">&nbsp;                encryptedSenderData,</b>
<b class="fc">&nbsp;              ).bind().decodeAs(SENDER_DATA_T)</b>
&nbsp;            }
&nbsp;          } finally {
<b class="fc">&nbsp;            senderDataNonce.wipe()</b>
<b class="fc">&nbsp;            senderDataKey.wipe()</b>
<b class="fc">&nbsp;          }</b>
&nbsp;
<b class="fc">&nbsp;        val leafIndex = senderData.field1</b>
<b class="fc">&nbsp;        val generation = senderData.field2</b>
<b class="fc">&nbsp;        val reuseGuard = senderData.field3</b>
&nbsp;
<b class="fc">&nbsp;        val (nonce, key) = secretTree.getNonceAndKey(leafIndex, contentType, generation)</b>
<b class="fc">&nbsp;        val guardedNonce = nonce xor reuseGuard</b>
&nbsp;
<b class="fc">&nbsp;        val plaintextContent =</b>
<b class="fc">&nbsp;          try {</b>
<b class="fc">&nbsp;            decryptAead(</b>
<b class="fc">&nbsp;              key,</b>
<b class="fc">&nbsp;              guardedNonce,</b>
<b class="fc">&nbsp;              AAD_T.encodeUnsafe(privateContentAad()).asAad,</b>
<b class="fc">&nbsp;              ciphertext,</b>
<b class="fc">&nbsp;            ).bind()</b>
&nbsp;          } finally {
<b class="fc">&nbsp;            nonce.wipe()</b>
<b class="fc">&nbsp;            guardedNonce.wipe()</b>
<b class="fc">&nbsp;            key.wipe()</b>
<b class="fc">&nbsp;          }</b>
&nbsp;
<b class="fc">&nbsp;        val (content, authData) =</b>
<b class="fc">&nbsp;          DecoderError.wrap {</b>
<b class="fc">&nbsp;            when (contentType) {</b>
<b class="fc">&nbsp;              ContentType.Application -&gt;</b>
<b class="fc">&nbsp;                plaintextContent.decodeWithPadding(APPLICATION_CONTENT_T)</b>
<b class="fc">&nbsp;                  .let { (content, signature) -&gt;</b>
<b class="fc">&nbsp;                    content to FramedContent.AuthData(signature, null)</b>
&nbsp;                  }
&nbsp;
<b class="fc">&nbsp;              ContentType.Proposal -&gt;</b>
<b class="fc">&nbsp;                plaintextContent.decodeWithPadding(PROPOSAL_CONTENT_T).let { (proposal, signature) -&gt;</b>
<b class="fc">&nbsp;                  proposal to FramedContent.AuthData(signature, null)</b>
&nbsp;                }
&nbsp;
<b class="pc">&nbsp;              ContentType.Commit -&gt;</b>
<b class="fc">&nbsp;                plaintextContent.decodeWithPadding(COMMIT_CONTENT_T)</b>
<b class="fc">&nbsp;                  .let { (commit, signature, confirmationTag) -&gt;</b>
<b class="fc">&nbsp;                    commit to FramedContent.AuthData(signature, confirmationTag)</b>
&nbsp;                  }
&nbsp;
<b class="nc">&nbsp;              else -&gt; error(&quot;Bad content type&quot;)</b>
&nbsp;            }
&nbsp;          }
&nbsp;
&nbsp;        @Suppress(&quot;UNCHECKED_CAST&quot;)
<b class="fc">&nbsp;        AuthenticatedContent(</b>
<b class="fc">&nbsp;          WireFormat.MlsPrivateMessage,</b>
<b class="fc">&nbsp;          FramedContent(</b>
<b class="fc">&nbsp;            groupId,</b>
<b class="fc">&nbsp;            epoch,</b>
<b class="fc">&nbsp;            Sender.member(leafIndex),</b>
<b class="fc">&nbsp;            authenticatedData,</b>
<b class="fc">&nbsp;            contentType,</b>
<b class="fc">&nbsp;            content as C,</b>
&nbsp;          ),
<b class="fc">&nbsp;          authData.signature,</b>
<b class="fc">&nbsp;          authData.confirmationTag,</b>
<b class="fc">&nbsp;        ).apply { verify(groupContext, signaturePublicKeyLookup.getSignaturePublicKey(groupContext, this.framedContent)) }</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;  companion object : Encodable&lt;PrivateMessage&lt;*&gt;&gt; {
&nbsp;    @Suppress(&quot;kotlin:S6531&quot;, &quot;ktlint:standard:property-naming&quot;)
<b class="fc">&nbsp;    override val T: DataType&lt;PrivateMessage&lt;*&gt;&gt; =</b>
<b class="fc">&nbsp;      struct(&quot;PrivateMessage&quot;) {</b>
<b class="fc">&nbsp;        it.field(&quot;group_id&quot;, GroupId.T)</b>
<b class="fc">&nbsp;          .field(&quot;epoch&quot;, uint64.asULong)</b>
<b class="fc">&nbsp;          .field(&quot;content_type&quot;, ContentType.T)</b>
<b class="fc">&nbsp;          .field(&quot;authenticated_data&quot;, opaque[V])</b>
<b class="fc">&nbsp;          .field(&quot;encrypted_sender_data&quot;, Ciphertext.T)</b>
<b class="fc">&nbsp;          .field(&quot;ciphertext&quot;, Ciphertext.T)</b>
<b class="fc">&nbsp;      }.lift { g, e, ct, aad, esd, ciph -&gt; PrivateMessage(g, e, ct as ContentType&lt;Content&lt;*&gt;&gt;, aad, esd, ciph) }</b>
&nbsp;
&nbsp;    context(Raise&lt;PrivateMessageSenderError&gt;)
&nbsp;    suspend fun &lt;C : Content&lt;C&gt;&gt; create(
&nbsp;      cipherSuite: ICipherSuite,
&nbsp;      authContent: AuthenticatedContent&lt;C&gt;,
&nbsp;      secretTree: SecretTree,
&nbsp;      senderDataSecret: Secret,
<b class="fc">&nbsp;      paddingStrategy: PaddingStrategy = Padme,</b>
&nbsp;    ): PrivateMessage&lt;C&gt; {
<b class="pc">&nbsp;      if (authContent.senderType != SenderType.Member) {</b>
<b class="nc">&nbsp;        raise(</b>
<b class="nc">&nbsp;          MessageSenderError.InvalidSenderType(</b>
<b class="nc">&nbsp;            authContent.senderType,</b>
<b class="nc">&nbsp;            &quot;Private messages can only be sent by members&quot;,</b>
&nbsp;          ),
&nbsp;        )
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      val leafIndex = authContent.sender.index!!</b>
<b class="fc">&nbsp;      val (nonce, key, generation) =</b>
<b class="fc">&nbsp;        secretTree.getNonceAndKey(leafIndex, authContent.contentType)</b>
<b class="fc">&nbsp;      val reuseGuard = ReuseGuard.random()</b>
<b class="fc">&nbsp;      val guardedNonce = nonce xor reuseGuard</b>
&nbsp;
<b class="fc">&nbsp;      val ciphertext =</b>
<b class="fc">&nbsp;        try {</b>
<b class="fc">&nbsp;          cipherSuite.encryptAead(</b>
<b class="fc">&nbsp;            key,</b>
<b class="fc">&nbsp;            guardedNonce,</b>
<b class="fc">&nbsp;            AAD_T.encodeUnsafe(aad(authContent.framedContent)).asAad,</b>
<b class="fc">&nbsp;            encodePrivateMessageContent(authContent, paddingStrategy),</b>
&nbsp;          )
&nbsp;        } finally {
<b class="fc">&nbsp;          nonce.wipe()</b>
<b class="fc">&nbsp;          guardedNonce.wipe()</b>
<b class="fc">&nbsp;          key.wipe()</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;      val senderData =</b>
<b class="fc">&nbsp;        SENDER_DATA_T.encodeUnsafe(Struct3(leafIndex, generation, reuseGuard))</b>
<b class="fc">&nbsp;      val (senderDataNonce, senderDataKey) = getSenderDataNonceAndKey(cipherSuite, senderDataSecret, ciphertext)</b>
<b class="fc">&nbsp;      val encryptedSenderData =</b>
<b class="fc">&nbsp;        try {</b>
<b class="fc">&nbsp;          cipherSuite.encryptAead(</b>
<b class="fc">&nbsp;            senderDataKey,</b>
<b class="fc">&nbsp;            senderDataNonce,</b>
<b class="fc">&nbsp;            SENDER_DATA_AAD_T.encodeUnsafe(senderDataAad(authContent.framedContent)).asAad,</b>
<b class="fc">&nbsp;            senderData,</b>
&nbsp;          )
&nbsp;        } finally {
<b class="fc">&nbsp;          senderDataNonce.wipe()</b>
<b class="fc">&nbsp;          senderDataKey.wipe()</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;      return PrivateMessage(authContent.framedContent, encryptedSenderData, ciphertext)</b>
&nbsp;    }
&nbsp;
&nbsp;    fun getSenderDataNonceAndKey(
&nbsp;      cipherSuite: ICipherSuite,
&nbsp;      senderDataSecret: Secret,
&nbsp;      ciphertext: Ciphertext,
&nbsp;    ): Pair&lt;Nonce, Secret&gt; =
<b class="fc">&nbsp;      with(cipherSuite) {</b>
<b class="fc">&nbsp;        ciphertext.bytes.sliceArray(0..&lt;minOf(ciphertext.size, hashLen.toInt())).let { ciphertextSample -&gt;</b>
<b class="fc">&nbsp;          expandWithLabel(</b>
<b class="fc">&nbsp;            senderDataSecret,</b>
<b class="fc">&nbsp;            &quot;nonce&quot;,</b>
<b class="fc">&nbsp;            ciphertextSample,</b>
<b class="fc">&nbsp;            nonceLen,</b>
<b class="fc">&nbsp;          ).asNonce to</b>
<b class="fc">&nbsp;            expandWithLabel(</b>
<b class="fc">&nbsp;              senderDataSecret,</b>
<b class="fc">&nbsp;              &quot;key&quot;,</b>
<b class="fc">&nbsp;              ciphertextSample,</b>
<b class="fc">&nbsp;              keyLen,</b>
&nbsp;            )
&nbsp;        }
&nbsp;      }
&nbsp;
&nbsp;    @Suppress(&quot;kotlin:S1481&quot;)
&nbsp;    private fun encodePrivateMessageContent(
&nbsp;      authContent: AuthenticatedContent&lt;*&gt;,
&nbsp;      paddingStrategy: PaddingStrategy,
&nbsp;    ): ByteArray {
<b class="fc">&nbsp;      val contentAndAuth =</b>
<b class="fc">&nbsp;        when (authContent.contentType) {</b>
<b class="fc">&nbsp;          ContentType.Application -&gt;</b>
<b class="fc">&nbsp;            APPLICATION_CONTENT_T.encodeUnsafe(</b>
<b class="fc">&nbsp;              Struct2(authContent.framedContent.content as ApplicationData, authContent.signature),</b>
&nbsp;            )
&nbsp;
<b class="fc">&nbsp;          ContentType.Proposal -&gt;</b>
<b class="fc">&nbsp;            PROPOSAL_CONTENT_T.encodeUnsafe(</b>
<b class="fc">&nbsp;              Struct2(authContent.framedContent.content as Proposal, authContent.signature),</b>
&nbsp;            )
&nbsp;
<b class="pc">&nbsp;          ContentType.Commit -&gt; {</b>
<b class="fc">&nbsp;            COMMIT_CONTENT_T.encodeUnsafe(</b>
<b class="pc">&nbsp;              Struct3(authContent.framedContent.content as Commit, authContent.signature, authContent.confirmationTag!!),</b>
&nbsp;            )
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          else -&gt; error(&quot;Bad content type&quot;)</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;      return paddingStrategy.applyPadding(contentAndAuth)</b>
&nbsp;    }
&nbsp;
&nbsp;    private val APPLICATION_CONTENT_T =
<b class="fc">&nbsp;      struct(&quot;PrivateMessageContent&quot;) {</b>
<b class="fc">&nbsp;        it.field(&quot;application_data&quot;, ApplicationData.T)</b>
<b class="fc">&nbsp;          .field(&quot;signature&quot;, Signature.T)</b>
&nbsp;      }
&nbsp;
&nbsp;    private val PROPOSAL_CONTENT_T =
<b class="fc">&nbsp;      struct(&quot;PrivateMessageContent&quot;) {</b>
<b class="fc">&nbsp;        it.field(&quot;proposal&quot;, Proposal.T)</b>
<b class="fc">&nbsp;          .field(&quot;signature&quot;, Signature.T)</b>
&nbsp;      }
&nbsp;
&nbsp;    private val COMMIT_CONTENT_T =
<b class="fc">&nbsp;      struct(&quot;PrivateMessageContent&quot;) {</b>
<b class="fc">&nbsp;        it.field(&quot;commit&quot;, Commit.T)</b>
<b class="fc">&nbsp;          .field(&quot;signature&quot;, Signature.T)</b>
<b class="fc">&nbsp;          .field(&quot;confirmation_tag&quot;, Mac.T)</b>
&nbsp;      }
&nbsp;
&nbsp;    private fun &lt;C : Content&lt;C&gt;&gt; aad(framedContent: FramedContent&lt;C&gt;): Struct4&lt;GroupId, ULong, ContentType&lt;C&gt;, ByteArray&gt; =
<b class="fc">&nbsp;      Struct4(framedContent.groupId, framedContent.epoch, framedContent.contentType, framedContent.authenticatedData)</b>
&nbsp;
&nbsp;    private val AAD_T =
<b class="fc">&nbsp;      struct(&quot;PrivateContentAAD&quot;) {</b>
<b class="fc">&nbsp;        it.field(&quot;group_id&quot;, GroupId.T)</b>
<b class="fc">&nbsp;          .field(&quot;epoch&quot;, uint64.asULong)</b>
<b class="fc">&nbsp;          .field(&quot;content_type&quot;, ContentType.T)</b>
<b class="fc">&nbsp;          .field(&quot;authenticated_data&quot;, opaque[V])</b>
&nbsp;      }
&nbsp;
&nbsp;    private val SENDER_DATA_T =
<b class="fc">&nbsp;      struct(&quot;SenderData&quot;) {</b>
<b class="fc">&nbsp;        it.field(&quot;leaf_index&quot;, LeafIndex.T)</b>
<b class="fc">&nbsp;          .field(&quot;generation&quot;, uint32.asUInt)</b>
<b class="fc">&nbsp;          .field(&quot;reuse_guard&quot;, ReuseGuard.T)</b>
&nbsp;      }
&nbsp;
&nbsp;    private fun &lt;C : Content&lt;C&gt;&gt; senderDataAad(framedContent: FramedContent&lt;C&gt;): Struct3&lt;GroupId, ULong, ContentType&lt;C&gt;&gt; =
<b class="fc">&nbsp;      Struct3(framedContent.groupId, framedContent.epoch, framedContent.contentType)</b>
&nbsp;
&nbsp;    private val SENDER_DATA_AAD_T =
<b class="fc">&nbsp;      struct(&quot;SenderDataAAD&quot;) {</b>
<b class="fc">&nbsp;        it.field(&quot;group_id&quot;, GroupId.T)</b>
<b class="fc">&nbsp;          .field(&quot;epoch&quot;, uint64.asULong)</b>
<b class="fc">&nbsp;          .field(&quot;content_type&quot;, ContentType.T)</b>
&nbsp;      }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-25 13:33</div>
</div>
</body>
</html>
