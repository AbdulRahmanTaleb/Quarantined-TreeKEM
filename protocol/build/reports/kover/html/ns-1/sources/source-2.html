


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>protocol Coverage Report > GroupClient</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: protocol<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.github.traderjoe95.mls.protocol.client</a>
</div>

<h1>Coverage Summary for Class: GroupClient (com.github.traderjoe95.mls.protocol.client)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">GroupClient</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.2%
  </span>
  <span class="absValue">
    (1/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.3%
  </span>
  <span class="absValue">
    (4/310)
  </span>
</td>
</tr>
  <tr>
    <td class="name">GroupClient$Companion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/88)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/362)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GroupClient$open$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">GroupClient$open$3</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">GroupClient$psks$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.2%
  </span>
  <span class="absValue">
    (1/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/132)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.6%
  </span>
  <span class="absValue">
    (4/680)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.github.traderjoe95.mls.protocol.client
&nbsp;
&nbsp;import arrow.core.Either
&nbsp;import arrow.core.flatMap
&nbsp;import arrow.core.left
&nbsp;import arrow.core.prependTo
&nbsp;import arrow.core.raise.Raise
&nbsp;import arrow.core.raise.either
&nbsp;import arrow.core.raise.ensure
&nbsp;import arrow.core.recover
&nbsp;import com.github.traderjoe95.mls.codec.util.uSize
&nbsp;import com.github.traderjoe95.mls.protocol.client.ProcessHandshakeResult.CommitProcessedWithNewMembers
&nbsp;import com.github.traderjoe95.mls.protocol.crypto.CipherSuite
&nbsp;import com.github.traderjoe95.mls.protocol.error.BranchError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreateAddError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreatePreSharedKeyError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreateReInitError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreateRemoveError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreateUpdateError
&nbsp;import com.github.traderjoe95.mls.protocol.error.DecoderError
&nbsp;import com.github.traderjoe95.mls.protocol.error.EpochError
&nbsp;import com.github.traderjoe95.mls.protocol.error.EpochError.EpochNotAvailable
&nbsp;import com.github.traderjoe95.mls.protocol.error.EpochError.FutureEpoch
&nbsp;import com.github.traderjoe95.mls.protocol.error.ExternalJoinError
&nbsp;import com.github.traderjoe95.mls.protocol.error.GroupCreationError
&nbsp;import com.github.traderjoe95.mls.protocol.error.GroupInfoError
&nbsp;import com.github.traderjoe95.mls.protocol.error.HistoryAccessError
&nbsp;import com.github.traderjoe95.mls.protocol.error.MessageRecipientError.WrongGroup
&nbsp;import com.github.traderjoe95.mls.protocol.error.PrivateMessageRecipientError
&nbsp;import com.github.traderjoe95.mls.protocol.error.PrivateMessageSenderError
&nbsp;import com.github.traderjoe95.mls.protocol.error.ProcessMessageError
&nbsp;import com.github.traderjoe95.mls.protocol.error.PskError
&nbsp;import com.github.traderjoe95.mls.protocol.error.ReInitError
&nbsp;import com.github.traderjoe95.mls.protocol.error.SenderCommitError
&nbsp;import com.github.traderjoe95.mls.protocol.error.WelcomeJoinError
&nbsp;import com.github.traderjoe95.mls.protocol.group.GroupState
&nbsp;import com.github.traderjoe95.mls.protocol.group.WelcomeMessages
&nbsp;import com.github.traderjoe95.mls.protocol.group.joinGroup
&nbsp;import com.github.traderjoe95.mls.protocol.group.joinGroupExternal
&nbsp;import com.github.traderjoe95.mls.protocol.group.prepareCommit
&nbsp;import com.github.traderjoe95.mls.protocol.group.resumption.branchGroup
&nbsp;import com.github.traderjoe95.mls.protocol.group.resumption.resumeReInit
&nbsp;import com.github.traderjoe95.mls.protocol.group.resumption.triggerReInit
&nbsp;import com.github.traderjoe95.mls.protocol.message.ApplicationMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.GroupInfo
&nbsp;import com.github.traderjoe95.mls.protocol.message.HandshakeMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.KeyPackage
&nbsp;import com.github.traderjoe95.mls.protocol.message.MessageOptions
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsHandshakeMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage.Companion.encodeUnsafe
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage.Companion.ensureFormat
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage.Companion.ensureFormatAndContent
&nbsp;import com.github.traderjoe95.mls.protocol.message.PrivateMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.UsePrivateMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.UsePublicMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.Welcome
&nbsp;import com.github.traderjoe95.mls.protocol.message.padding.randomized.CovertPadding
&nbsp;import com.github.traderjoe95.mls.protocol.psk.ExternalPskHolder
&nbsp;import com.github.traderjoe95.mls.protocol.psk.ExternalPskId
&nbsp;import com.github.traderjoe95.mls.protocol.psk.PreSharedKeyId
&nbsp;import com.github.traderjoe95.mls.protocol.psk.PskLookup
&nbsp;import com.github.traderjoe95.mls.protocol.psk.PskLookup.Companion.delegatingTo
&nbsp;import com.github.traderjoe95.mls.protocol.psk.ResumptionPskId
&nbsp;import com.github.traderjoe95.mls.protocol.service.AuthenticationService
&nbsp;import com.github.traderjoe95.mls.protocol.tree.LeafIndex
&nbsp;import com.github.traderjoe95.mls.protocol.tree.PublicRatchetTree
&nbsp;import com.github.traderjoe95.mls.protocol.tree.nonBlankLeafIndices
&nbsp;import com.github.traderjoe95.mls.protocol.types.GroupContextExtension
&nbsp;import com.github.traderjoe95.mls.protocol.types.GroupId
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.HashReference
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Secret
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.ApplicationData
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.AuthenticatedContent
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Proposal
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.enums.ContentType
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.enums.WireFormat
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.LeafNode
&nbsp;import com.github.traderjoe95.mls.protocol.util.hex
&nbsp;
<b class="nc">&nbsp;sealed class GroupClient&lt;Identity : Any, State : GroupState&gt;(</b>
<b class="nc">&nbsp;  internal val stateHistory: MutableList&lt;GroupState&gt;,</b>
<b class="nc">&nbsp;  internal val authService: AuthenticationService&lt;Identity&gt;,</b>
<b class="nc">&nbsp;  internal val managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;  internal val parentPskLookup: PskLookup? = managedBy,</b>
&nbsp;) : PskLookup {
&nbsp;  val cipherSuite: CipherSuite
<b class="nc">&nbsp;    get() = state.cipherSuite</b>
&nbsp;  val groupId: GroupId
<b class="nc">&nbsp;    get() = state.groupId</b>
&nbsp;  val epoch: ULong
<b class="nc">&nbsp;    get() = state.epoch</b>
&nbsp;  val tree: PublicRatchetTree
<b class="nc">&nbsp;    get() = state.tree.public</b>
&nbsp;  val members: List&lt;LeafNode&lt;*&gt;&gt;
<b class="nc">&nbsp;    get() = state.members</b>
&nbsp;  val epochAuthenticator: Secret
<b class="nc">&nbsp;    get() = state.keySchedule.epochAuthenticator</b>
&nbsp;
&nbsp;  val state: State
<b class="nc">&nbsp;    get() = stateHistory.first().coerceState()</b>
&nbsp;
<b class="nc">&nbsp;  protected val psks: PskLookup by lazy { this delegatingTo parentPskLookup }</b>
&nbsp;
&nbsp;  suspend fun open(applicationMessage: ByteArray): Either&lt;PrivateMessageRecipientError, AuthenticatedContent&lt;ApplicationData&gt;&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      val msg =</b>
<b class="nc">&nbsp;        decodeMessage(applicationMessage).bind()</b>
<b class="nc">&nbsp;          .ensureFormatAndContent&lt;_, PrivateMessage&lt;ApplicationData&gt;&gt;(</b>
<b class="nc">&nbsp;            WireFormat.MlsPrivateMessage,</b>
<b class="nc">&nbsp;            ContentType.Application,</b>
&nbsp;          )
&nbsp;
<b class="nc">&nbsp;      open(msg.message).bind()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun open(applicationMessage: ApplicationMessage): Either&lt;PrivateMessageRecipientError, AuthenticatedContent&lt;ApplicationData&gt;&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      getStateForEpoch(applicationMessage.groupId, applicationMessage.epoch)</b>
<b class="nc">&nbsp;        .ensureActive { applicationMessage.unprotect(this) }</b>
<b class="nc">&nbsp;        .bind()</b>
&nbsp;    }
&nbsp;
&nbsp;  override suspend fun getPreSharedKey(id: PreSharedKeyId): Either&lt;PskError, Secret&gt; =
<b class="nc">&nbsp;    when (id) {</b>
<b class="nc">&nbsp;      is ResumptionPskId -&gt;</b>
<b class="nc">&nbsp;        either { getStateForEpoch(id.pskGroupId, id.pskEpoch) }</b>
<b class="nc">&nbsp;          .recover {</b>
<b class="nc">&nbsp;            when (it) {</b>
<b class="nc">&nbsp;              is EpochError -&gt; raise(it)</b>
<b class="nc">&nbsp;              else -&gt; raise(PskError.PskNotFound(id))</b>
&nbsp;            }
&nbsp;          }
<b class="nc">&nbsp;          .flatMap {</b>
<b class="nc">&nbsp;            when (it) {</b>
<b class="nc">&nbsp;              is PskLookup -&gt; it.getPreSharedKey(id)</b>
<b class="nc">&nbsp;              else -&gt; PskError.PskNotFound(id).left()</b>
&nbsp;            }
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;      is ExternalPskId -&gt; PskError.PskNotFound(id).left()</b>
&nbsp;    }
&nbsp;
&nbsp;  protected abstract fun GroupState.coerceState(): State
&nbsp;
&nbsp;  context(Raise&lt;HistoryAccessError&gt;)
&nbsp;  internal fun getStateForEpoch(
&nbsp;    groupId: GroupId,
&nbsp;    epoch: ULong,
&nbsp;  ): GroupState {
<b class="nc">&nbsp;    ensure(groupId eq this@GroupClient.groupId) { WrongGroup(groupId, this@GroupClient.groupId) }</b>
&nbsp;
<b class="nc">&nbsp;    ensure(epoch &lt;= this@GroupClient.epoch) { FutureEpoch(groupId, epoch, this@GroupClient.epoch) }</b>
&nbsp;
<b class="nc">&nbsp;    return stateHistory</b>
<b class="nc">&nbsp;      .find { it.epoch == epoch }</b>
<b class="nc">&nbsp;      ?: raise(EpochNotAvailable(groupId, epoch))</b>
&nbsp;  }
&nbsp;
&nbsp;  protected fun replaceCurrentState(newState: GroupState) {
<b class="nc">&nbsp;    stateHistory[0] = newState</b>
&nbsp;  }
&nbsp;
&nbsp;  protected open fun advanceCurrentState(newState: GroupState) {
<b class="nc">&nbsp;    stateHistory.add(0, newState)</b>
&nbsp;  }
&nbsp;
&nbsp;  companion object {
&nbsp;    @JvmStatic
&nbsp;    fun &lt;Identity : Any&gt; newGroup(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      ownKeyPackage: KeyPackage.Private,
<b class="nc">&nbsp;      groupId: GroupId? = null,</b>
&nbsp;    ): Either&lt;GroupCreationError, ActiveGroupClient&lt;Identity&gt;&gt; =
<b class="nc">&nbsp;      newGroup(ownKeyPackage, managedBy.authenticationService, groupId, managedBy)</b>
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    fun &lt;Identity : Any&gt; newGroup(
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
<b class="nc">&nbsp;      groupId: GroupId? = null,</b>
<b class="nc">&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;      parentPskLookup: PskLookup? = managedBy,</b>
&nbsp;    ): Either&lt;GroupCreationError, ActiveGroupClient&lt;Identity&gt;&gt; =
<b class="nc">&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)</b>
<b class="nc">&nbsp;        .createNew(groupId)</b>
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromWelcomeMessage(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      welcomeMessageBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
<b class="nc">&nbsp;      resumingFrom: GroupState? = null,</b>
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
&nbsp;    ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
<b class="nc">&nbsp;      joinFromWelcomeMessage(</b>
<b class="nc">&nbsp;        welcomeMessageBytes,</b>
<b class="nc">&nbsp;        ownKeyPackage,</b>
<b class="nc">&nbsp;        managedBy.authenticationService,</b>
<b class="nc">&nbsp;        resumingFrom,</b>
<b class="nc">&nbsp;        optionalTree,</b>
<b class="nc">&nbsp;        managedBy,</b>
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromWelcomeMessage(
&nbsp;      welcomeMessageBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
<b class="nc">&nbsp;      resumingFrom: GroupState? = null,</b>
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
<b class="nc">&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;      parentPskLookup: PskLookup? = managedBy,</b>
&nbsp;    ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
<b class="nc">&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)</b>
<b class="nc">&nbsp;        .processWelcomeMessage(welcomeMessageBytes, optionalTree, resumingFrom)</b>
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromWelcome(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      welcome: Welcome,
&nbsp;      ownKeyPackage: KeyPackage.Private,
<b class="nc">&nbsp;      resumingFrom: GroupState? = null,</b>
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
&nbsp;    ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
<b class="nc">&nbsp;      joinFromWelcome(</b>
<b class="nc">&nbsp;        welcome,</b>
<b class="nc">&nbsp;        ownKeyPackage,</b>
<b class="nc">&nbsp;        managedBy.authenticationService,</b>
<b class="nc">&nbsp;        resumingFrom,</b>
<b class="nc">&nbsp;        optionalTree,</b>
<b class="nc">&nbsp;        managedBy,</b>
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromWelcome(
&nbsp;      welcome: Welcome,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
<b class="nc">&nbsp;      resumingFrom: GroupState? = null,</b>
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
<b class="nc">&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;      parentPskLookup: PskLookup? = managedBy,</b>
&nbsp;    ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
<b class="nc">&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)</b>
<b class="nc">&nbsp;        .processWelcome(welcome, optionalTree, resumingFrom)</b>
&nbsp;
&nbsp;    @JvmStatic
<b class="nc">&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfoMessage(</b>
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      groupInfoMessageBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
<b class="nc">&nbsp;      joinFromGroupInfoMessage(</b>
<b class="nc">&nbsp;        groupInfoMessageBytes,</b>
<b class="nc">&nbsp;        ownKeyPackage,</b>
<b class="nc">&nbsp;        managedBy.authenticationService,</b>
<b class="nc">&nbsp;        commitAuthenticatedData,</b>
<b class="nc">&nbsp;        optionalTree,</b>
<b class="nc">&nbsp;        managedBy,</b>
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
<b class="nc">&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfoMessage(</b>
&nbsp;      groupInfoMessageBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
<b class="nc">&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;      parentPskLookup: PskLookup? = managedBy,</b>
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
<b class="nc">&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)</b>
<b class="nc">&nbsp;        .processGroupInfoMessage(groupInfoMessageBytes, commitAuthenticatedData, optionalTree)</b>
&nbsp;
&nbsp;    @JvmStatic
<b class="nc">&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfo(</b>
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      groupInfoBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
<b class="nc">&nbsp;      joinFromGroupInfo(</b>
<b class="nc">&nbsp;        groupInfoBytes,</b>
<b class="nc">&nbsp;        ownKeyPackage,</b>
<b class="nc">&nbsp;        managedBy.authenticationService,</b>
<b class="nc">&nbsp;        commitAuthenticatedData,</b>
<b class="nc">&nbsp;        optionalTree,</b>
<b class="nc">&nbsp;        managedBy,</b>
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
<b class="nc">&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfo(</b>
&nbsp;      groupInfoBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
<b class="nc">&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;      parentPskLookup: PskLookup? = managedBy,</b>
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
<b class="nc">&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)</b>
<b class="nc">&nbsp;        .processGroupInfo(groupInfoBytes, commitAuthenticatedData, optionalTree)</b>
&nbsp;
&nbsp;    @JvmStatic
<b class="nc">&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfo(</b>
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      groupInfo: GroupInfo,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
<b class="nc">&nbsp;      joinFromGroupInfo(</b>
<b class="nc">&nbsp;        groupInfo,</b>
<b class="nc">&nbsp;        ownKeyPackage,</b>
<b class="nc">&nbsp;        managedBy.authenticationService,</b>
<b class="nc">&nbsp;        commitAuthenticatedData,</b>
<b class="nc">&nbsp;        optionalTree,</b>
<b class="nc">&nbsp;        managedBy,</b>
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
<b class="nc">&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfo(</b>
&nbsp;      groupInfo: GroupInfo,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
<b class="nc">&nbsp;      optionalTree: PublicRatchetTree? = null,</b>
<b class="nc">&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;      parentPskLookup: PskLookup? = managedBy,</b>
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
<b class="nc">&nbsp;      JoiningGroupClient(</b>
<b class="nc">&nbsp;        ownKeyPackage,</b>
<b class="nc">&nbsp;        authenticationService,</b>
<b class="nc">&nbsp;        managedBy,</b>
<b class="nc">&nbsp;        parentPskLookup,</b>
<b class="nc">&nbsp;      ).processGroupInfo(groupInfo, commitAuthenticatedData, optionalTree)</b>
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    internal fun decodeMessage(byteArray: ByteArray): Either&lt;DecoderError, MlsMessage&lt;*&gt;&gt; =
<b class="nc">&nbsp;      either {</b>
<b class="nc">&nbsp;        DecoderError.wrap { MlsMessage.decode(byteArray) }</b>
&nbsp;      }
&nbsp;  }
&nbsp;}
&nbsp;
&nbsp;class JoiningGroupClient&lt;Identity : Any&gt; internal constructor(
&nbsp;  private val keyPackage: KeyPackage.Private,
&nbsp;  private val authService: AuthenticationService&lt;Identity&gt;,
&nbsp;  private val managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;  private val pskLookup: PskLookup? = managedBy,
&nbsp;) : ExternalPskHolder&lt;JoiningGroupClient&lt;Identity&gt;&gt; {
&nbsp;  private val externalPsks: MutableMap&lt;String, Secret&gt; = mutableMapOf()
&nbsp;  private val psks: PskLookup = this delegatingTo pskLookup
&nbsp;
&nbsp;  fun createNew(groupId: GroupId? = null): Either&lt;GroupCreationError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;    com.github.traderjoe95.mls.protocol.group.newGroup(keyPackage, groupId = groupId)
&nbsp;      .map {
&nbsp;        ActiveGroupClient(
&nbsp;          mutableListOf(it),
&nbsp;          authService,
&nbsp;          managedBy = managedBy,
&nbsp;          parentPskLookup = pskLookup,
&nbsp;        ).also { managedBy?.register(it) }
&nbsp;      }
&nbsp;
&nbsp;  suspend fun processWelcomeMessage(
&nbsp;    messageBytes: ByteArray,
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;    resumingFrom: GroupState? = null,
&nbsp;  ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;    either {
&nbsp;      val msg = GroupClient.decodeMessage(messageBytes).bind().ensureFormat&lt;Welcome&gt;(WireFormat.MlsWelcome)
&nbsp;      processWelcome(msg.message, optionalTree, resumingFrom).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processWelcome(
&nbsp;    welcome: Welcome,
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;    resumingFrom: GroupState? = null,
&nbsp;  ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;    either {
&nbsp;      val groupState =
&nbsp;        welcome.joinGroup(
&nbsp;          keyPackage,
&nbsp;          authService,
&nbsp;          psks = psks,
&nbsp;          optionalTree = optionalTree,
&nbsp;          resumingFrom = resumingFrom,
&nbsp;        ).bind()
&nbsp;
&nbsp;      ActiveGroupClient(
&nbsp;        mutableListOf(groupState),
&nbsp;        authService,
&nbsp;        managedBy = managedBy,
&nbsp;        parentPskLookup = pskLookup,
&nbsp;      ).also { managedBy?.register(it) }
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processGroupInfoMessage(
&nbsp;    messageBytes: ByteArray,
&nbsp;    commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;  ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;    either {
&nbsp;      val msg = GroupClient.decodeMessage(messageBytes).bind().ensureFormat&lt;GroupInfo&gt;(WireFormat.MlsGroupInfo)
&nbsp;      processGroupInfo(msg.message, commitAuthenticatedData, optionalTree).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processGroupInfo(
&nbsp;    groupInfoBytes: ByteArray,
&nbsp;    commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;  ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;    either {
&nbsp;      val groupInfo = DecoderError.wrap { GroupInfo.decode(groupInfoBytes) }
&nbsp;
&nbsp;      processGroupInfo(groupInfo, commitAuthenticatedData, optionalTree).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processGroupInfo(
&nbsp;    groupInfo: GroupInfo,
&nbsp;    commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;  ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;    either {
&nbsp;      val (groupState, commitMsg) =
&nbsp;        groupInfo.joinGroupExternal(
&nbsp;          keyPackage,
&nbsp;          authService,
&nbsp;          authenticatedData = commitAuthenticatedData,
&nbsp;          optionalTree = optionalTree,
&nbsp;        ).bind()
&nbsp;
&nbsp;      ActiveGroupClient(
&nbsp;        mutableListOf(groupState),
&nbsp;        authService,
&nbsp;        managedBy = managedBy,
&nbsp;        parentPskLookup = pskLookup,
&nbsp;      ).also { managedBy?.register(it) } to commitMsg.encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  override fun registerExternalPsk(
&nbsp;    pskId: ByteArray,
&nbsp;    psk: Secret,
&nbsp;  ): JoiningGroupClient&lt;Identity&gt; =
&nbsp;    apply {
&nbsp;      externalPsks[pskId.hex] = psk
&nbsp;    }
&nbsp;
&nbsp;  override fun deleteExternalPsk(pskId: ByteArray): JoiningGroupClient&lt;Identity&gt; = apply { externalPsks.remove(pskId.hex) }
&nbsp;
&nbsp;  override fun clearExternalPsks(): JoiningGroupClient&lt;Identity&gt; = apply { externalPsks.clear() }
&nbsp;
&nbsp;  override suspend fun getPreSharedKey(id: PreSharedKeyId): Either&lt;PskError, Secret&gt; =
&nbsp;    either {
&nbsp;      when (id) {
&nbsp;        is ExternalPskId -&gt; externalPsks[id.pskId.hex] ?: raise(PskError.PskNotFound(id))
&nbsp;        is ResumptionPskId -&gt; raise(PskError.PskNotFound(id))
&nbsp;      }
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;class ActiveGroupClient&lt;Identity : Any&gt; internal constructor(
&nbsp;  stateHistory: MutableList&lt;GroupState&gt;,
&nbsp;  authService: AuthenticationService&lt;Identity&gt;,
&nbsp;  var applicationMessageOptions: UsePrivateMessage = UsePrivateMessage(paddingStrategy = CovertPadding()),
&nbsp;  var handshakeMessageOptions: MessageOptions = UsePublicMessage,
&nbsp;  managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;  parentPskLookup: PskLookup? = managedBy,
&nbsp;) : GroupClient&lt;Identity, GroupState.Active&gt;(stateHistory, authService, managedBy, parentPskLookup),
&nbsp;  ExternalPskHolder&lt;ActiveGroupClient&lt;Identity&gt;&gt; {
&nbsp;  internal constructor(
&nbsp;    state: GroupState.Active,
&nbsp;    authService: AuthenticationService&lt;Identity&gt;,
&nbsp;    applicationMessageOptions: UsePrivateMessage = UsePrivateMessage(paddingStrategy = CovertPadding()),
&nbsp;    handshakeMessageOptions: MessageOptions = UsePublicMessage,
&nbsp;    managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;    parentPskLookup: PskLookup? = managedBy,
&nbsp;  ) : this(
&nbsp;    mutableListOf(state),
&nbsp;    authService,
&nbsp;    applicationMessageOptions,
&nbsp;    handshakeMessageOptions,
&nbsp;    managedBy,
&nbsp;    parentPskLookup,
&nbsp;  )
&nbsp;
&nbsp;  private val externalPsks: MutableMap&lt;String, Secret&gt; = mutableMapOf()
&nbsp;  private val commitCache: MutableMap&lt;String, CachedCommit&gt; = mutableMapOf()
&nbsp;
&nbsp;  suspend fun seal(
&nbsp;    data: ApplicationData,
&nbsp;    authenticatedData: ByteArray = byteArrayOf(),
&nbsp;  ): Either&lt;PrivateMessageSenderError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      state.ensureActive { messages.applicationMessage(data, applicationMessageOptions, authenticatedData) }
&nbsp;        .bind()
&nbsp;        .encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processHandshake(handshakeMessageBytes: ByteArray): Either&lt;ProcessMessageError, ProcessHandshakeResult&lt;Identity&gt;&gt; =
&nbsp;    either {
&nbsp;      val msg: MlsHandshakeMessage =
&nbsp;        decodeMessage(handshakeMessageBytes).bind()
&nbsp;          .ensureFormat&lt;HandshakeMessage&gt;(handshakeMessageOptions.wireFormat)
&nbsp;
&nbsp;      processHandshake(msg.message).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processHandshake(handshakeMessage: HandshakeMessage): Either&lt;ProcessMessageError, ProcessHandshakeResult&lt;Identity&gt;&gt; =
&nbsp;    either {
&nbsp;      with(authService) {
&nbsp;        val cached = commitCache[makeCommitRef(handshakeMessage).hex]
&nbsp;
&nbsp;        val newState =
&nbsp;          state.ensureActive {
&nbsp;            process(handshakeMessage, authService, psks = psks, cachedState = cached?.newState)
&nbsp;          }.bind()
&nbsp;
&nbsp;        when (newState.epoch) {
&nbsp;          epoch -&gt; {
&nbsp;            replaceCurrentState(newState)
&nbsp;            ProcessHandshakeResult.ProposalReceived
&nbsp;          }
&nbsp;
&nbsp;          else -&gt;
&nbsp;            when (newState) {
&nbsp;              is GroupState.Active -&gt; {
&nbsp;                advanceCurrentState(newState)
&nbsp;                cached?.welcomeMessages
&nbsp;                  ?.takeIf { it.isNotEmpty() }
&nbsp;                  ?.let(::CommitProcessedWithNewMembers)
&nbsp;                  ?: ProcessHandshakeResult.CommitProcessed
&nbsp;              }
&nbsp;
&nbsp;              is GroupState.Suspended -&gt;
&nbsp;                ProcessHandshakeResult.ReInitProcessed(SuspendedGroupClient(this@ActiveGroupClient, newState))
&nbsp;            }
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;  suspend fun addMember(keyPackage: KeyPackage): Either&lt;CreateAddError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      state.messages
&nbsp;        .add(keyPackage, handshakeMessageOptions)
&nbsp;        .bind()
&nbsp;        .encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun addMember(keyPackageBytes: ByteArray): Either&lt;CreateAddError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      addMember(DecoderError.wrap { KeyPackage.decode(keyPackageBytes) }).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun update(): Either&lt;CreateUpdateError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      state.messages
&nbsp;        .update(state.updateLeafNode(cipherSuite.generateHpkeKeyPair()), handshakeMessageOptions)
&nbsp;        .bind()
&nbsp;        .encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun removeMember(memberIdx: UInt): Either&lt;CreateRemoveError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      state.messages
&nbsp;        .remove(leafIndexFor(memberIdx).bind(), handshakeMessageOptions)
&nbsp;        .bind()
&nbsp;        .encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun injectExternalPsk(pskId: ByteArray): Either&lt;CreatePreSharedKeyError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      state.messages
&nbsp;        .preSharedKey(pskId, psks = psks, options = handshakeMessageOptions)
&nbsp;        .bind()
&nbsp;        .encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun injectResumptionPsk(
&nbsp;    epoch: ULong,
&nbsp;    groupId: GroupId = this.groupId,
&nbsp;  ): Either&lt;CreatePreSharedKeyError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      state.messages
&nbsp;        .preSharedKey(groupId, epoch, psks = psks, options = handshakeMessageOptions)
&nbsp;        .bind()
&nbsp;        .encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun proposeReInit(
&nbsp;    newCipherSuite: CipherSuite,
&nbsp;    newExtensions: List&lt;GroupContextExtension&lt;*&gt;&gt; = state.extensions,
&nbsp;    newGroupId: GroupId? = null,
&nbsp;  ): Either&lt;CreateReInitError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      state.messages
&nbsp;        .reInit(newCipherSuite, extensions = newExtensions, groupId = newGroupId, options = handshakeMessageOptions)
&nbsp;        .bind()
&nbsp;        .encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  @JvmOverloads
&nbsp;  suspend fun commit(
&nbsp;    additionalProposals: List&lt;Proposal&gt; = listOf(),
&nbsp;    proposalFilter: (Proposal) -&gt; Boolean = { true },
&nbsp;  ): Either&lt;SenderCommitError, ByteArray&gt; =
&nbsp;    either {
&nbsp;      val proposalRefs =
&nbsp;        state.getStoredProposals()
&nbsp;          .sortedBy { it.received }
&nbsp;          .filter { proposalFilter(it.proposal) }
&nbsp;          .map { it.ref }
&nbsp;
&nbsp;      val (newState, commitMsg, welcomeMsgs) =
&nbsp;        state.prepareCommit(proposalRefs + additionalProposals, authService, handshakeMessageOptions, psks = psks)
&nbsp;          .bind()
&nbsp;
&nbsp;      commitMsg.encodeUnsafe().also {
&nbsp;        commitCache[makeCommitRef(commitMsg.message).hex] = CachedCommit(newState, welcomeMsgs)
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;  suspend fun branch(
&nbsp;    ownKeyPackage: KeyPackage.Private,
&nbsp;    otherMembers: List&lt;KeyPackage&gt;,
&nbsp;    groupId: GroupId? = null,
&nbsp;  ): Either&lt;BranchError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, WelcomeMessages&gt;&gt; =
&nbsp;    either {
&nbsp;      val (branchedGroup, welcome) =
&nbsp;        state.branchGroup(ownKeyPackage, otherMembers, authService, groupId = groupId).bind()
&nbsp;
&nbsp;      ActiveGroupClient(
&nbsp;        branchedGroup,
&nbsp;        authService,
&nbsp;        applicationMessageOptions,
&nbsp;        handshakeMessageOptions,
&nbsp;        managedBy,
&nbsp;        parentPskLookup,
&nbsp;      ).also { managedBy?.register(it) } to welcome
&nbsp;    }
&nbsp;
&nbsp;  suspend fun triggerReInit(
&nbsp;    newCipherSuite: CipherSuite,
&nbsp;    newExtensions: List&lt;GroupContextExtension&lt;*&gt;&gt; = state.extensions,
&nbsp;    newGroupId: GroupId? = null,
&nbsp;  ): Either&lt;ReInitError, ByteArray&gt; =
&nbsp;    state.triggerReInit(
&nbsp;      authService,
&nbsp;      groupId = newGroupId,
&nbsp;      cipherSuite = newCipherSuite,
&nbsp;      extensions = newExtensions,
&nbsp;      messageOptions = handshakeMessageOptions,
&nbsp;    ).map { (suspendedGroup, commitMsg) -&gt;
&nbsp;      commitMsg.encodeUnsafe().also {
&nbsp;        commitCache[makeCommitRef(commitMsg.message).hex] = CachedCommit(suspendedGroup, listOf())
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;  fun groupInfo(): Either&lt;GroupInfoError, GroupInfo&gt; =
&nbsp;    either {
&nbsp;      state.groupInfo(inlineTree = true, public = true).bind()
&nbsp;    }
&nbsp;
&nbsp;  fun leafIndexFor(memberIdx: UInt): Either&lt;CreateRemoveError.MemberIndexOutOfBounds, LeafIndex&gt; =
&nbsp;    either {
&nbsp;      members.uSize.let {
&nbsp;        ensure(memberIdx &lt; it) { CreateRemoveError.MemberIndexOutOfBounds(memberIdx, it) }
&nbsp;      }
&nbsp;
&nbsp;      tree.nonBlankLeafIndices[memberIdx.toInt()]
&nbsp;    }
&nbsp;
&nbsp;  override fun registerExternalPsk(
&nbsp;    pskId: ByteArray,
&nbsp;    psk: Secret,
&nbsp;  ): ActiveGroupClient&lt;Identity&gt; =
&nbsp;    apply {
&nbsp;      externalPsks[pskId.hex] = psk
&nbsp;    }
&nbsp;
&nbsp;  override fun deleteExternalPsk(pskId: ByteArray): ActiveGroupClient&lt;Identity&gt; = apply { externalPsks.remove(pskId.hex) }
&nbsp;
&nbsp;  override fun clearExternalPsks(): ActiveGroupClient&lt;Identity&gt; = apply { externalPsks.clear() }
&nbsp;
&nbsp;  override suspend fun getPreSharedKey(id: PreSharedKeyId): Either&lt;PskError, Secret&gt; =
&nbsp;    when (id) {
&nbsp;      is ResumptionPskId -&gt;
&nbsp;        either { getStateForEpoch(id.pskGroupId, id.pskEpoch) }
&nbsp;          .recover {
&nbsp;            when (it) {
&nbsp;              is EpochError -&gt; raise(it)
&nbsp;              else -&gt; raise(PskError.PskNotFound(id))
&nbsp;            }
&nbsp;          }
&nbsp;          .flatMap {
&nbsp;            when (it) {
&nbsp;              is PskLookup -&gt; it.getPreSharedKey(id)
&nbsp;              else -&gt; PskError.PskNotFound(id).left()
&nbsp;            }
&nbsp;          }
&nbsp;
&nbsp;      is ExternalPskId -&gt; either { externalPsks[id.pskId.hex] ?: raise(PskError.PskNotFound(id)) }
&nbsp;    }
&nbsp;
&nbsp;  override fun GroupState.coerceState(): GroupState.Active = coerceActive()
&nbsp;
&nbsp;  override fun advanceCurrentState(newState: GroupState) {
&nbsp;    super.advanceCurrentState(newState)
&nbsp;    commitCache.clear()
&nbsp;  }
&nbsp;
&nbsp;  private fun makeCommitRef(commit: HandshakeMessage): HashReference = cipherSuite.refHash(&quot;CommitRef&quot;, commit.encoded)
&nbsp;
&nbsp;  private data class CachedCommit(
&nbsp;    val newState: GroupState,
&nbsp;    val welcomeMessages: WelcomeMessages,
&nbsp;  )
&nbsp;}
&nbsp;
&nbsp;class SuspendedGroupClient&lt;Identity : Any&gt; internal constructor(
&nbsp;  private val lastActiveState: ActiveGroupClient&lt;Identity&gt;,
&nbsp;  suspendedState: GroupState.Suspended,
&nbsp;) : GroupClient&lt;Identity, GroupState.Suspended&gt;(
&nbsp;    suspendedState.prependTo(lastActiveState.stateHistory).toMutableList(),
&nbsp;    lastActiveState.authService,
&nbsp;    managedBy = lastActiveState.managedBy,
&nbsp;    parentPskLookup = null,
&nbsp;  ) {
&nbsp;  init {
&nbsp;    lastActiveState.managedBy?.register(this)
&nbsp;  }
&nbsp;
&nbsp;  suspend fun resume(
&nbsp;    ownKeyPackage: KeyPackage.Private,
&nbsp;    otherKeyPackages: List&lt;KeyPackage&gt;,
&nbsp;  ): Either&lt;ReInitError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, WelcomeMessages&gt;&gt; =
&nbsp;    either {
&nbsp;      val (newGroup, welcomeMessages) = state.resumeReInit(ownKeyPackage, otherKeyPackages, authService).bind()
&nbsp;
&nbsp;      ActiveGroupClient(
&nbsp;        mutableListOf(newGroup),
&nbsp;        authService,
&nbsp;        lastActiveState.applicationMessageOptions,
&nbsp;        lastActiveState.handshakeMessageOptions,
&nbsp;        managedBy,
&nbsp;        parentPskLookup = lastActiveState.parentPskLookup,
&nbsp;      ).also { managedBy?.register(it) } to welcomeMessages
&nbsp;    }
&nbsp;
&nbsp;  override fun GroupState.coerceState(): GroupState.Suspended = coerceSuspended()
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-25 13:33</div>
</div>
</body>
</html>
