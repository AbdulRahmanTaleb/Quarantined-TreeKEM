


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>protocol Coverage Report > ActiveGroupClient</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: protocol<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.github.traderjoe95.mls.protocol.client</a>
</div>

<h1>Coverage Summary for Class: ActiveGroupClient (com.github.traderjoe95.mls.protocol.client)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">ActiveGroupClient</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.2%
  </span>
  <span class="absValue">
    (2/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/149)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1069)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ActiveGroupClient$addMember$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$addMember$3</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$branch$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$CachedCommit</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$commit$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$commit$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$commit$lambda$19$$inlined$sortedBy$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$injectExternalPsk$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$injectResumptionPsk$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$processHandshake$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$processHandshake$3</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$proposeReInit$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$removeMember$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$seal$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$triggerReInit$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">ActiveGroupClient$update$1</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.2%
  </span>
  <span class="absValue">
    (2/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/153)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1083)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.github.traderjoe95.mls.protocol.client
&nbsp;
&nbsp;import arrow.core.Either
&nbsp;import arrow.core.flatMap
&nbsp;import arrow.core.left
&nbsp;import arrow.core.prependTo
&nbsp;import arrow.core.raise.Raise
&nbsp;import arrow.core.raise.either
&nbsp;import arrow.core.raise.ensure
&nbsp;import arrow.core.recover
&nbsp;import com.github.traderjoe95.mls.codec.util.uSize
&nbsp;import com.github.traderjoe95.mls.protocol.client.ProcessHandshakeResult.CommitProcessedWithNewMembers
&nbsp;import com.github.traderjoe95.mls.protocol.crypto.CipherSuite
&nbsp;import com.github.traderjoe95.mls.protocol.error.BranchError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreateAddError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreatePreSharedKeyError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreateReInitError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreateRemoveError
&nbsp;import com.github.traderjoe95.mls.protocol.error.CreateUpdateError
&nbsp;import com.github.traderjoe95.mls.protocol.error.DecoderError
&nbsp;import com.github.traderjoe95.mls.protocol.error.EpochError
&nbsp;import com.github.traderjoe95.mls.protocol.error.EpochError.EpochNotAvailable
&nbsp;import com.github.traderjoe95.mls.protocol.error.EpochError.FutureEpoch
&nbsp;import com.github.traderjoe95.mls.protocol.error.ExternalJoinError
&nbsp;import com.github.traderjoe95.mls.protocol.error.GroupCreationError
&nbsp;import com.github.traderjoe95.mls.protocol.error.GroupInfoError
&nbsp;import com.github.traderjoe95.mls.protocol.error.HistoryAccessError
&nbsp;import com.github.traderjoe95.mls.protocol.error.MessageRecipientError.WrongGroup
&nbsp;import com.github.traderjoe95.mls.protocol.error.PrivateMessageRecipientError
&nbsp;import com.github.traderjoe95.mls.protocol.error.PrivateMessageSenderError
&nbsp;import com.github.traderjoe95.mls.protocol.error.ProcessMessageError
&nbsp;import com.github.traderjoe95.mls.protocol.error.PskError
&nbsp;import com.github.traderjoe95.mls.protocol.error.ReInitError
&nbsp;import com.github.traderjoe95.mls.protocol.error.SenderCommitError
&nbsp;import com.github.traderjoe95.mls.protocol.error.WelcomeJoinError
&nbsp;import com.github.traderjoe95.mls.protocol.group.GroupState
&nbsp;import com.github.traderjoe95.mls.protocol.group.WelcomeMessages
&nbsp;import com.github.traderjoe95.mls.protocol.group.joinGroup
&nbsp;import com.github.traderjoe95.mls.protocol.group.joinGroupExternal
&nbsp;import com.github.traderjoe95.mls.protocol.group.prepareCommit
&nbsp;import com.github.traderjoe95.mls.protocol.group.resumption.branchGroup
&nbsp;import com.github.traderjoe95.mls.protocol.group.resumption.resumeReInit
&nbsp;import com.github.traderjoe95.mls.protocol.group.resumption.triggerReInit
&nbsp;import com.github.traderjoe95.mls.protocol.message.ApplicationMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.GroupInfo
&nbsp;import com.github.traderjoe95.mls.protocol.message.HandshakeMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.KeyPackage
&nbsp;import com.github.traderjoe95.mls.protocol.message.MessageOptions
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsHandshakeMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage.Companion.encodeUnsafe
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage.Companion.ensureFormat
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage.Companion.ensureFormatAndContent
&nbsp;import com.github.traderjoe95.mls.protocol.message.PrivateMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.UsePrivateMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.UsePublicMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.Welcome
&nbsp;import com.github.traderjoe95.mls.protocol.message.padding.randomized.CovertPadding
&nbsp;import com.github.traderjoe95.mls.protocol.psk.ExternalPskHolder
&nbsp;import com.github.traderjoe95.mls.protocol.psk.ExternalPskId
&nbsp;import com.github.traderjoe95.mls.protocol.psk.PreSharedKeyId
&nbsp;import com.github.traderjoe95.mls.protocol.psk.PskLookup
&nbsp;import com.github.traderjoe95.mls.protocol.psk.PskLookup.Companion.delegatingTo
&nbsp;import com.github.traderjoe95.mls.protocol.psk.ResumptionPskId
&nbsp;import com.github.traderjoe95.mls.protocol.service.AuthenticationService
&nbsp;import com.github.traderjoe95.mls.protocol.tree.LeafIndex
&nbsp;import com.github.traderjoe95.mls.protocol.tree.PublicRatchetTree
&nbsp;import com.github.traderjoe95.mls.protocol.tree.nonBlankLeafIndices
&nbsp;import com.github.traderjoe95.mls.protocol.types.GroupContextExtension
&nbsp;import com.github.traderjoe95.mls.protocol.types.GroupId
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.HashReference
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Secret
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.ApplicationData
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.AuthenticatedContent
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Proposal
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.enums.ContentType
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.enums.WireFormat
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.LeafNode
&nbsp;import com.github.traderjoe95.mls.protocol.util.hex
&nbsp;
&nbsp;sealed class GroupClient&lt;Identity : Any, State : GroupState&gt;(
&nbsp;  internal val stateHistory: MutableList&lt;GroupState&gt;,
&nbsp;  internal val authService: AuthenticationService&lt;Identity&gt;,
&nbsp;  internal val managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;  internal val parentPskLookup: PskLookup? = managedBy,
&nbsp;) : PskLookup {
&nbsp;  val cipherSuite: CipherSuite
&nbsp;    get() = state.cipherSuite
&nbsp;  val groupId: GroupId
&nbsp;    get() = state.groupId
&nbsp;  val epoch: ULong
&nbsp;    get() = state.epoch
&nbsp;  val tree: PublicRatchetTree
&nbsp;    get() = state.tree.public
&nbsp;  val members: List&lt;LeafNode&lt;*&gt;&gt;
&nbsp;    get() = state.members
&nbsp;  val epochAuthenticator: Secret
&nbsp;    get() = state.keySchedule.epochAuthenticator
&nbsp;
&nbsp;  val state: State
&nbsp;    get() = stateHistory.first().coerceState()
&nbsp;
&nbsp;  protected val psks: PskLookup by lazy { this delegatingTo parentPskLookup }
&nbsp;
&nbsp;  suspend fun open(applicationMessage: ByteArray): Either&lt;PrivateMessageRecipientError, AuthenticatedContent&lt;ApplicationData&gt;&gt; =
&nbsp;    either {
&nbsp;      val msg =
&nbsp;        decodeMessage(applicationMessage).bind()
&nbsp;          .ensureFormatAndContent&lt;_, PrivateMessage&lt;ApplicationData&gt;&gt;(
&nbsp;            WireFormat.MlsPrivateMessage,
&nbsp;            ContentType.Application,
&nbsp;          )
&nbsp;
&nbsp;      open(msg.message).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun open(applicationMessage: ApplicationMessage): Either&lt;PrivateMessageRecipientError, AuthenticatedContent&lt;ApplicationData&gt;&gt; =
&nbsp;    either {
&nbsp;      getStateForEpoch(applicationMessage.groupId, applicationMessage.epoch)
&nbsp;        .ensureActive { applicationMessage.unprotect(this) }
&nbsp;        .bind()
&nbsp;    }
&nbsp;
&nbsp;  override suspend fun getPreSharedKey(id: PreSharedKeyId): Either&lt;PskError, Secret&gt; =
&nbsp;    when (id) {
&nbsp;      is ResumptionPskId -&gt;
&nbsp;        either { getStateForEpoch(id.pskGroupId, id.pskEpoch) }
&nbsp;          .recover {
&nbsp;            when (it) {
&nbsp;              is EpochError -&gt; raise(it)
&nbsp;              else -&gt; raise(PskError.PskNotFound(id))
&nbsp;            }
&nbsp;          }
&nbsp;          .flatMap {
&nbsp;            when (it) {
&nbsp;              is PskLookup -&gt; it.getPreSharedKey(id)
&nbsp;              else -&gt; PskError.PskNotFound(id).left()
&nbsp;            }
&nbsp;          }
&nbsp;
&nbsp;      is ExternalPskId -&gt; PskError.PskNotFound(id).left()
&nbsp;    }
&nbsp;
&nbsp;  protected abstract fun GroupState.coerceState(): State
&nbsp;
&nbsp;  context(Raise&lt;HistoryAccessError&gt;)
&nbsp;  internal fun getStateForEpoch(
&nbsp;    groupId: GroupId,
&nbsp;    epoch: ULong,
&nbsp;  ): GroupState {
&nbsp;    ensure(groupId eq this@GroupClient.groupId) { WrongGroup(groupId, this@GroupClient.groupId) }
&nbsp;
&nbsp;    ensure(epoch &lt;= this@GroupClient.epoch) { FutureEpoch(groupId, epoch, this@GroupClient.epoch) }
&nbsp;
&nbsp;    return stateHistory
&nbsp;      .find { it.epoch == epoch }
&nbsp;      ?: raise(EpochNotAvailable(groupId, epoch))
&nbsp;  }
&nbsp;
&nbsp;  protected fun replaceCurrentState(newState: GroupState) {
&nbsp;    stateHistory[0] = newState
&nbsp;  }
&nbsp;
&nbsp;  protected open fun advanceCurrentState(newState: GroupState) {
&nbsp;    stateHistory.add(0, newState)
&nbsp;  }
&nbsp;
&nbsp;  companion object {
&nbsp;    @JvmStatic
&nbsp;    fun &lt;Identity : Any&gt; newGroup(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      groupId: GroupId? = null,
&nbsp;    ): Either&lt;GroupCreationError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;      newGroup(ownKeyPackage, managedBy.authenticationService, groupId, managedBy)
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    fun &lt;Identity : Any&gt; newGroup(
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      groupId: GroupId? = null,
&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;      parentPskLookup: PskLookup? = managedBy,
&nbsp;    ): Either&lt;GroupCreationError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)
&nbsp;        .createNew(groupId)
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromWelcomeMessage(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      welcomeMessageBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      resumingFrom: GroupState? = null,
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;    ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;      joinFromWelcomeMessage(
&nbsp;        welcomeMessageBytes,
&nbsp;        ownKeyPackage,
&nbsp;        managedBy.authenticationService,
&nbsp;        resumingFrom,
&nbsp;        optionalTree,
&nbsp;        managedBy,
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromWelcomeMessage(
&nbsp;      welcomeMessageBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      resumingFrom: GroupState? = null,
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;      parentPskLookup: PskLookup? = managedBy,
&nbsp;    ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)
&nbsp;        .processWelcomeMessage(welcomeMessageBytes, optionalTree, resumingFrom)
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromWelcome(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      welcome: Welcome,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      resumingFrom: GroupState? = null,
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;    ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;      joinFromWelcome(
&nbsp;        welcome,
&nbsp;        ownKeyPackage,
&nbsp;        managedBy.authenticationService,
&nbsp;        resumingFrom,
&nbsp;        optionalTree,
&nbsp;        managedBy,
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromWelcome(
&nbsp;      welcome: Welcome,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      resumingFrom: GroupState? = null,
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;      parentPskLookup: PskLookup? = managedBy,
&nbsp;    ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)
&nbsp;        .processWelcome(welcome, optionalTree, resumingFrom)
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfoMessage(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      groupInfoMessageBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;      joinFromGroupInfoMessage(
&nbsp;        groupInfoMessageBytes,
&nbsp;        ownKeyPackage,
&nbsp;        managedBy.authenticationService,
&nbsp;        commitAuthenticatedData,
&nbsp;        optionalTree,
&nbsp;        managedBy,
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfoMessage(
&nbsp;      groupInfoMessageBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;      parentPskLookup: PskLookup? = managedBy,
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)
&nbsp;        .processGroupInfoMessage(groupInfoMessageBytes, commitAuthenticatedData, optionalTree)
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfo(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      groupInfoBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;      joinFromGroupInfo(
&nbsp;        groupInfoBytes,
&nbsp;        ownKeyPackage,
&nbsp;        managedBy.authenticationService,
&nbsp;        commitAuthenticatedData,
&nbsp;        optionalTree,
&nbsp;        managedBy,
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfo(
&nbsp;      groupInfoBytes: ByteArray,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;      parentPskLookup: PskLookup? = managedBy,
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;      JoiningGroupClient(ownKeyPackage, authenticationService, managedBy, parentPskLookup)
&nbsp;        .processGroupInfo(groupInfoBytes, commitAuthenticatedData, optionalTree)
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfo(
&nbsp;      managedBy: MlsClient&lt;Identity&gt;,
&nbsp;      groupInfo: GroupInfo,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;      joinFromGroupInfo(
&nbsp;        groupInfo,
&nbsp;        ownKeyPackage,
&nbsp;        managedBy.authenticationService,
&nbsp;        commitAuthenticatedData,
&nbsp;        optionalTree,
&nbsp;        managedBy,
&nbsp;      )
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    suspend fun &lt;Identity : Any&gt; joinFromGroupInfo(
&nbsp;      groupInfo: GroupInfo,
&nbsp;      ownKeyPackage: KeyPackage.Private,
&nbsp;      authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;      commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;      optionalTree: PublicRatchetTree? = null,
&nbsp;      managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;      parentPskLookup: PskLookup? = managedBy,
&nbsp;    ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;      JoiningGroupClient(
&nbsp;        ownKeyPackage,
&nbsp;        authenticationService,
&nbsp;        managedBy,
&nbsp;        parentPskLookup,
&nbsp;      ).processGroupInfo(groupInfo, commitAuthenticatedData, optionalTree)
&nbsp;
&nbsp;    @JvmStatic
&nbsp;    internal fun decodeMessage(byteArray: ByteArray): Either&lt;DecoderError, MlsMessage&lt;*&gt;&gt; =
&nbsp;      either {
&nbsp;        DecoderError.wrap { MlsMessage.decode(byteArray) }
&nbsp;      }
&nbsp;  }
&nbsp;}
&nbsp;
&nbsp;class JoiningGroupClient&lt;Identity : Any&gt; internal constructor(
&nbsp;  private val keyPackage: KeyPackage.Private,
&nbsp;  private val authService: AuthenticationService&lt;Identity&gt;,
&nbsp;  private val managedBy: MlsClient&lt;Identity&gt;? = null,
&nbsp;  private val pskLookup: PskLookup? = managedBy,
&nbsp;) : ExternalPskHolder&lt;JoiningGroupClient&lt;Identity&gt;&gt; {
&nbsp;  private val externalPsks: MutableMap&lt;String, Secret&gt; = mutableMapOf()
&nbsp;  private val psks: PskLookup = this delegatingTo pskLookup
&nbsp;
&nbsp;  fun createNew(groupId: GroupId? = null): Either&lt;GroupCreationError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;    com.github.traderjoe95.mls.protocol.group.newGroup(keyPackage, groupId = groupId)
&nbsp;      .map {
&nbsp;        ActiveGroupClient(
&nbsp;          mutableListOf(it),
&nbsp;          authService,
&nbsp;          managedBy = managedBy,
&nbsp;          parentPskLookup = pskLookup,
&nbsp;        ).also { managedBy?.register(it) }
&nbsp;      }
&nbsp;
&nbsp;  suspend fun processWelcomeMessage(
&nbsp;    messageBytes: ByteArray,
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;    resumingFrom: GroupState? = null,
&nbsp;  ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;    either {
&nbsp;      val msg = GroupClient.decodeMessage(messageBytes).bind().ensureFormat&lt;Welcome&gt;(WireFormat.MlsWelcome)
&nbsp;      processWelcome(msg.message, optionalTree, resumingFrom).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processWelcome(
&nbsp;    welcome: Welcome,
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;    resumingFrom: GroupState? = null,
&nbsp;  ): Either&lt;WelcomeJoinError, ActiveGroupClient&lt;Identity&gt;&gt; =
&nbsp;    either {
&nbsp;      val groupState =
&nbsp;        welcome.joinGroup(
&nbsp;          keyPackage,
&nbsp;          authService,
&nbsp;          psks = psks,
&nbsp;          optionalTree = optionalTree,
&nbsp;          resumingFrom = resumingFrom,
&nbsp;        ).bind()
&nbsp;
&nbsp;      ActiveGroupClient(
&nbsp;        mutableListOf(groupState),
&nbsp;        authService,
&nbsp;        managedBy = managedBy,
&nbsp;        parentPskLookup = pskLookup,
&nbsp;      ).also { managedBy?.register(it) }
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processGroupInfoMessage(
&nbsp;    messageBytes: ByteArray,
&nbsp;    commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;  ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;    either {
&nbsp;      val msg = GroupClient.decodeMessage(messageBytes).bind().ensureFormat&lt;GroupInfo&gt;(WireFormat.MlsGroupInfo)
&nbsp;      processGroupInfo(msg.message, commitAuthenticatedData, optionalTree).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processGroupInfo(
&nbsp;    groupInfoBytes: ByteArray,
&nbsp;    commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;  ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;    either {
&nbsp;      val groupInfo = DecoderError.wrap { GroupInfo.decode(groupInfoBytes) }
&nbsp;
&nbsp;      processGroupInfo(groupInfo, commitAuthenticatedData, optionalTree).bind()
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processGroupInfo(
&nbsp;    groupInfo: GroupInfo,
&nbsp;    commitAuthenticatedData: ByteArray = byteArrayOf(),
&nbsp;    optionalTree: PublicRatchetTree? = null,
&nbsp;  ): Either&lt;ExternalJoinError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, ByteArray&gt;&gt; =
&nbsp;    either {
&nbsp;      val (groupState, commitMsg) =
&nbsp;        groupInfo.joinGroupExternal(
&nbsp;          keyPackage,
&nbsp;          authService,
&nbsp;          authenticatedData = commitAuthenticatedData,
&nbsp;          optionalTree = optionalTree,
&nbsp;        ).bind()
&nbsp;
&nbsp;      ActiveGroupClient(
&nbsp;        mutableListOf(groupState),
&nbsp;        authService,
&nbsp;        managedBy = managedBy,
&nbsp;        parentPskLookup = pskLookup,
&nbsp;      ).also { managedBy?.register(it) } to commitMsg.encodeUnsafe()
&nbsp;    }
&nbsp;
&nbsp;  override fun registerExternalPsk(
&nbsp;    pskId: ByteArray,
&nbsp;    psk: Secret,
&nbsp;  ): JoiningGroupClient&lt;Identity&gt; =
&nbsp;    apply {
&nbsp;      externalPsks[pskId.hex] = psk
&nbsp;    }
&nbsp;
&nbsp;  override fun deleteExternalPsk(pskId: ByteArray): JoiningGroupClient&lt;Identity&gt; = apply { externalPsks.remove(pskId.hex) }
&nbsp;
&nbsp;  override fun clearExternalPsks(): JoiningGroupClient&lt;Identity&gt; = apply { externalPsks.clear() }
&nbsp;
&nbsp;  override suspend fun getPreSharedKey(id: PreSharedKeyId): Either&lt;PskError, Secret&gt; =
&nbsp;    either {
&nbsp;      when (id) {
&nbsp;        is ExternalPskId -&gt; externalPsks[id.pskId.hex] ?: raise(PskError.PskNotFound(id))
&nbsp;        is ResumptionPskId -&gt; raise(PskError.PskNotFound(id))
&nbsp;      }
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;class ActiveGroupClient&lt;Identity : Any&gt; internal constructor(
&nbsp;  stateHistory: MutableList&lt;GroupState&gt;,
&nbsp;  authService: AuthenticationService&lt;Identity&gt;,
<b class="nc">&nbsp;  var applicationMessageOptions: UsePrivateMessage = UsePrivateMessage(paddingStrategy = CovertPadding()),</b>
<b class="nc">&nbsp;  var handshakeMessageOptions: MessageOptions = UsePublicMessage,</b>
<b class="nc">&nbsp;  managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;  parentPskLookup: PskLookup? = managedBy,</b>
<b class="nc">&nbsp;) : GroupClient&lt;Identity, GroupState.Active&gt;(stateHistory, authService, managedBy, parentPskLookup),</b>
&nbsp;  ExternalPskHolder&lt;ActiveGroupClient&lt;Identity&gt;&gt; {
&nbsp;  internal constructor(
&nbsp;    state: GroupState.Active,
&nbsp;    authService: AuthenticationService&lt;Identity&gt;,
<b class="nc">&nbsp;    applicationMessageOptions: UsePrivateMessage = UsePrivateMessage(paddingStrategy = CovertPadding()),</b>
<b class="nc">&nbsp;    handshakeMessageOptions: MessageOptions = UsePublicMessage,</b>
<b class="nc">&nbsp;    managedBy: MlsClient&lt;Identity&gt;? = null,</b>
<b class="nc">&nbsp;    parentPskLookup: PskLookup? = managedBy,</b>
<b class="nc">&nbsp;  ) : this(</b>
<b class="nc">&nbsp;    mutableListOf(state),</b>
<b class="nc">&nbsp;    authService,</b>
<b class="nc">&nbsp;    applicationMessageOptions,</b>
<b class="nc">&nbsp;    handshakeMessageOptions,</b>
<b class="nc">&nbsp;    managedBy,</b>
<b class="nc">&nbsp;    parentPskLookup,</b>
&nbsp;  )
&nbsp;
<b class="nc">&nbsp;  private val externalPsks: MutableMap&lt;String, Secret&gt; = mutableMapOf()</b>
<b class="nc">&nbsp;  private val commitCache: MutableMap&lt;String, CachedCommit&gt; = mutableMapOf()</b>
&nbsp;
<b class="nc">&nbsp;  suspend fun seal(</b>
&nbsp;    data: ApplicationData,
&nbsp;    authenticatedData: ByteArray = byteArrayOf(),
&nbsp;  ): Either&lt;PrivateMessageSenderError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      state.ensureActive { messages.applicationMessage(data, applicationMessageOptions, authenticatedData) }</b>
<b class="nc">&nbsp;        .bind()</b>
<b class="nc">&nbsp;        .encodeUnsafe()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processHandshake(handshakeMessageBytes: ByteArray): Either&lt;ProcessMessageError, ProcessHandshakeResult&lt;Identity&gt;&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      val msg: MlsHandshakeMessage =</b>
<b class="nc">&nbsp;        decodeMessage(handshakeMessageBytes).bind()</b>
<b class="nc">&nbsp;          .ensureFormat&lt;HandshakeMessage&gt;(handshakeMessageOptions.wireFormat)</b>
&nbsp;
<b class="nc">&nbsp;      processHandshake(msg.message).bind()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun processHandshake(handshakeMessage: HandshakeMessage): Either&lt;ProcessMessageError, ProcessHandshakeResult&lt;Identity&gt;&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      with(authService) {</b>
<b class="nc">&nbsp;        val cached = commitCache[makeCommitRef(handshakeMessage).hex]</b>
&nbsp;
<b class="nc">&nbsp;        val newState =</b>
<b class="nc">&nbsp;          state.ensureActive {</b>
<b class="nc">&nbsp;            process(handshakeMessage, authService, psks = psks, cachedState = cached?.newState)</b>
<b class="nc">&nbsp;          }.bind()</b>
&nbsp;
<b class="nc">&nbsp;        when (newState.epoch) {</b>
<b class="nc">&nbsp;          epoch -&gt; {</b>
<b class="nc">&nbsp;            replaceCurrentState(newState)</b>
<b class="nc">&nbsp;            ProcessHandshakeResult.ProposalReceived</b>
&nbsp;          }
&nbsp;
&nbsp;          else -&gt;
<b class="nc">&nbsp;            when (newState) {</b>
<b class="nc">&nbsp;              is GroupState.Active -&gt; {</b>
<b class="nc">&nbsp;                advanceCurrentState(newState)</b>
<b class="nc">&nbsp;                cached?.welcomeMessages</b>
<b class="nc">&nbsp;                  ?.takeIf { it.isNotEmpty() }</b>
<b class="nc">&nbsp;                  ?.let(::CommitProcessedWithNewMembers)</b>
<b class="nc">&nbsp;                  ?: ProcessHandshakeResult.CommitProcessed</b>
&nbsp;              }
&nbsp;
<b class="nc">&nbsp;              is GroupState.Suspended -&gt;</b>
<b class="nc">&nbsp;                ProcessHandshakeResult.ReInitProcessed(SuspendedGroupClient(this@ActiveGroupClient, newState))</b>
&nbsp;            }
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;  suspend fun addMember(keyPackage: KeyPackage): Either&lt;CreateAddError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      state.messages</b>
<b class="nc">&nbsp;        .add(keyPackage, handshakeMessageOptions)</b>
<b class="nc">&nbsp;        .bind()</b>
<b class="nc">&nbsp;        .encodeUnsafe()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun addMember(keyPackageBytes: ByteArray): Either&lt;CreateAddError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      addMember(DecoderError.wrap { KeyPackage.decode(keyPackageBytes) }).bind()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun update(): Either&lt;CreateUpdateError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      state.messages</b>
<b class="nc">&nbsp;        .update(state.updateLeafNode(cipherSuite.generateHpkeKeyPair()), handshakeMessageOptions)</b>
<b class="nc">&nbsp;        .bind()</b>
<b class="nc">&nbsp;        .encodeUnsafe()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun removeMember(memberIdx: UInt): Either&lt;CreateRemoveError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      state.messages</b>
<b class="nc">&nbsp;        .remove(leafIndexFor(memberIdx).bind(), handshakeMessageOptions)</b>
<b class="nc">&nbsp;        .bind()</b>
<b class="nc">&nbsp;        .encodeUnsafe()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun injectExternalPsk(pskId: ByteArray): Either&lt;CreatePreSharedKeyError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      state.messages</b>
<b class="nc">&nbsp;        .preSharedKey(pskId, psks = psks, options = handshakeMessageOptions)</b>
<b class="nc">&nbsp;        .bind()</b>
<b class="nc">&nbsp;        .encodeUnsafe()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun injectResumptionPsk(
&nbsp;    epoch: ULong,
<b class="nc">&nbsp;    groupId: GroupId = this.groupId,</b>
&nbsp;  ): Either&lt;CreatePreSharedKeyError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      state.messages</b>
<b class="nc">&nbsp;        .preSharedKey(groupId, epoch, psks = psks, options = handshakeMessageOptions)</b>
<b class="nc">&nbsp;        .bind()</b>
<b class="nc">&nbsp;        .encodeUnsafe()</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun proposeReInit(
&nbsp;    newCipherSuite: CipherSuite,
<b class="nc">&nbsp;    newExtensions: List&lt;GroupContextExtension&lt;*&gt;&gt; = state.extensions,</b>
<b class="nc">&nbsp;    newGroupId: GroupId? = null,</b>
&nbsp;  ): Either&lt;CreateReInitError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      state.messages</b>
<b class="nc">&nbsp;        .reInit(newCipherSuite, extensions = newExtensions, groupId = newGroupId, options = handshakeMessageOptions)</b>
<b class="nc">&nbsp;        .bind()</b>
<b class="nc">&nbsp;        .encodeUnsafe()</b>
&nbsp;    }
&nbsp;
&nbsp;  @JvmOverloads
&nbsp;  suspend fun commit(
<b class="nc">&nbsp;    additionalProposals: List&lt;Proposal&gt; = listOf(),</b>
<b class="nc">&nbsp;    proposalFilter: (Proposal) -&gt; Boolean = { true },</b>
&nbsp;  ): Either&lt;SenderCommitError, ByteArray&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      val proposalRefs =</b>
<b class="nc">&nbsp;        state.getStoredProposals()</b>
<b class="nc">&nbsp;          .sortedBy { it.received }</b>
<b class="nc">&nbsp;          .filter { proposalFilter(it.proposal) }</b>
<b class="nc">&nbsp;          .map { it.ref }</b>
&nbsp;
<b class="nc">&nbsp;      val (newState, commitMsg, welcomeMsgs) =</b>
<b class="nc">&nbsp;        state.prepareCommit(proposalRefs + additionalProposals, authService, handshakeMessageOptions, psks = psks)</b>
<b class="nc">&nbsp;          .bind()</b>
&nbsp;
<b class="nc">&nbsp;      commitMsg.encodeUnsafe().also {</b>
<b class="nc">&nbsp;        commitCache[makeCommitRef(commitMsg.message).hex] = CachedCommit(newState, welcomeMsgs)</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun branch(
&nbsp;    ownKeyPackage: KeyPackage.Private,
&nbsp;    otherMembers: List&lt;KeyPackage&gt;,
<b class="nc">&nbsp;    groupId: GroupId? = null,</b>
&nbsp;  ): Either&lt;BranchError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, WelcomeMessages&gt;&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      val (branchedGroup, welcome) =</b>
<b class="nc">&nbsp;        state.branchGroup(ownKeyPackage, otherMembers, authService, groupId = groupId).bind()</b>
&nbsp;
<b class="nc">&nbsp;      ActiveGroupClient(</b>
<b class="nc">&nbsp;        branchedGroup,</b>
<b class="nc">&nbsp;        authService,</b>
<b class="nc">&nbsp;        applicationMessageOptions,</b>
<b class="nc">&nbsp;        handshakeMessageOptions,</b>
<b class="nc">&nbsp;        managedBy,</b>
<b class="nc">&nbsp;        parentPskLookup,</b>
<b class="nc">&nbsp;      ).also { managedBy?.register(it) } to welcome</b>
&nbsp;    }
&nbsp;
&nbsp;  suspend fun triggerReInit(
&nbsp;    newCipherSuite: CipherSuite,
<b class="nc">&nbsp;    newExtensions: List&lt;GroupContextExtension&lt;*&gt;&gt; = state.extensions,</b>
<b class="nc">&nbsp;    newGroupId: GroupId? = null,</b>
&nbsp;  ): Either&lt;ReInitError, ByteArray&gt; =
<b class="nc">&nbsp;    state.triggerReInit(</b>
<b class="nc">&nbsp;      authService,</b>
<b class="nc">&nbsp;      groupId = newGroupId,</b>
<b class="nc">&nbsp;      cipherSuite = newCipherSuite,</b>
<b class="nc">&nbsp;      extensions = newExtensions,</b>
<b class="nc">&nbsp;      messageOptions = handshakeMessageOptions,</b>
<b class="nc">&nbsp;    ).map { (suspendedGroup, commitMsg) -&gt;</b>
<b class="nc">&nbsp;      commitMsg.encodeUnsafe().also {</b>
<b class="nc">&nbsp;        commitCache[makeCommitRef(commitMsg.message).hex] = CachedCommit(suspendedGroup, listOf())</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;  fun groupInfo(): Either&lt;GroupInfoError, GroupInfo&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      state.groupInfo(inlineTree = true, public = true).bind()</b>
&nbsp;    }
&nbsp;
&nbsp;  fun leafIndexFor(memberIdx: UInt): Either&lt;CreateRemoveError.MemberIndexOutOfBounds, LeafIndex&gt; =
<b class="nc">&nbsp;    either {</b>
<b class="nc">&nbsp;      members.uSize.let {</b>
<b class="nc">&nbsp;        ensure(memberIdx &lt; it) { CreateRemoveError.MemberIndexOutOfBounds(memberIdx, it) }</b>
<b class="nc">&nbsp;      }</b>
&nbsp;
<b class="nc">&nbsp;      tree.nonBlankLeafIndices[memberIdx.toInt()]</b>
&nbsp;    }
&nbsp;
&nbsp;  override fun registerExternalPsk(
&nbsp;    pskId: ByteArray,
&nbsp;    psk: Secret,
&nbsp;  ): ActiveGroupClient&lt;Identity&gt; =
<b class="nc">&nbsp;    apply {</b>
<b class="nc">&nbsp;      externalPsks[pskId.hex] = psk</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;  override fun deleteExternalPsk(pskId: ByteArray): ActiveGroupClient&lt;Identity&gt; = apply { externalPsks.remove(pskId.hex) }</b>
&nbsp;
<b class="nc">&nbsp;  override fun clearExternalPsks(): ActiveGroupClient&lt;Identity&gt; = apply { externalPsks.clear() }</b>
&nbsp;
&nbsp;  override suspend fun getPreSharedKey(id: PreSharedKeyId): Either&lt;PskError, Secret&gt; =
<b class="nc">&nbsp;    when (id) {</b>
<b class="nc">&nbsp;      is ResumptionPskId -&gt;</b>
<b class="nc">&nbsp;        either { getStateForEpoch(id.pskGroupId, id.pskEpoch) }</b>
<b class="nc">&nbsp;          .recover {</b>
<b class="nc">&nbsp;            when (it) {</b>
<b class="nc">&nbsp;              is EpochError -&gt; raise(it)</b>
<b class="nc">&nbsp;              else -&gt; raise(PskError.PskNotFound(id))</b>
&nbsp;            }
&nbsp;          }
<b class="nc">&nbsp;          .flatMap {</b>
<b class="nc">&nbsp;            when (it) {</b>
<b class="nc">&nbsp;              is PskLookup -&gt; it.getPreSharedKey(id)</b>
<b class="nc">&nbsp;              else -&gt; PskError.PskNotFound(id).left()</b>
&nbsp;            }
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;      is ExternalPskId -&gt; either { externalPsks[id.pskId.hex] ?: raise(PskError.PskNotFound(id)) }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;  override fun GroupState.coerceState(): GroupState.Active = coerceActive()</b>
&nbsp;
&nbsp;  override fun advanceCurrentState(newState: GroupState) {
<b class="nc">&nbsp;    super.advanceCurrentState(newState)</b>
<b class="nc">&nbsp;    commitCache.clear()</b>
&nbsp;  }
&nbsp;
<b class="nc">&nbsp;  private fun makeCommitRef(commit: HandshakeMessage): HashReference = cipherSuite.refHash(&quot;CommitRef&quot;, commit.encoded)</b>
&nbsp;
<b class="nc">&nbsp;  private data class CachedCommit(</b>
<b class="nc">&nbsp;    val newState: GroupState,</b>
<b class="nc">&nbsp;    val welcomeMessages: WelcomeMessages,</b>
&nbsp;  )
&nbsp;}
&nbsp;
&nbsp;class SuspendedGroupClient&lt;Identity : Any&gt; internal constructor(
&nbsp;  private val lastActiveState: ActiveGroupClient&lt;Identity&gt;,
&nbsp;  suspendedState: GroupState.Suspended,
&nbsp;) : GroupClient&lt;Identity, GroupState.Suspended&gt;(
&nbsp;    suspendedState.prependTo(lastActiveState.stateHistory).toMutableList(),
&nbsp;    lastActiveState.authService,
&nbsp;    managedBy = lastActiveState.managedBy,
&nbsp;    parentPskLookup = null,
&nbsp;  ) {
&nbsp;  init {
&nbsp;    lastActiveState.managedBy?.register(this)
&nbsp;  }
&nbsp;
&nbsp;  suspend fun resume(
&nbsp;    ownKeyPackage: KeyPackage.Private,
&nbsp;    otherKeyPackages: List&lt;KeyPackage&gt;,
&nbsp;  ): Either&lt;ReInitError, Pair&lt;ActiveGroupClient&lt;Identity&gt;, WelcomeMessages&gt;&gt; =
&nbsp;    either {
&nbsp;      val (newGroup, welcomeMessages) = state.resumeReInit(ownKeyPackage, otherKeyPackages, authService).bind()
&nbsp;
&nbsp;      ActiveGroupClient(
&nbsp;        mutableListOf(newGroup),
&nbsp;        authService,
&nbsp;        lastActiveState.applicationMessageOptions,
&nbsp;        lastActiveState.handshakeMessageOptions,
&nbsp;        managedBy,
&nbsp;        parentPskLookup = lastActiveState.parentPskLookup,
&nbsp;      ).also { managedBy?.register(it) } to welcomeMessages
&nbsp;    }
&nbsp;
&nbsp;  override fun GroupState.coerceState(): GroupState.Suspended = coerceSuspended()
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-25 13:33</div>
</div>
</body>
</html>
