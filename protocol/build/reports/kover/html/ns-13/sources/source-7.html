


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>protocol Coverage Report > PrivateRatchetTree</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: protocol<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.github.traderjoe95.mls.protocol.tree</a>
</div>

<h1>Coverage Summary for Class: PrivateRatchetTree (com.github.traderjoe95.mls.protocol.tree)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">PrivateRatchetTree</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (31/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    99.7%
  </span>
  <span class="absValue">
    (333/334)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PrivateRatchetTree$getPrivateKey$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (32/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PrivateRatchetTree$insertPathSecrets$newPathSecrets$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PrivateRatchetTree$sam$java_util_function_Function$0</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (33/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    99.7%
  </span>
  <span class="absValue">
    (371/372)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.github.traderjoe95.mls.protocol.tree
&nbsp;
&nbsp;import arrow.core.Option
&nbsp;import arrow.core.prependTo
&nbsp;import arrow.core.raise.Raise
&nbsp;import com.github.traderjoe95.mls.codec.Encodable
&nbsp;import com.github.traderjoe95.mls.codec.error.DecoderError
&nbsp;import com.github.traderjoe95.mls.codec.type.DataType
&nbsp;import com.github.traderjoe95.mls.codec.type.V
&nbsp;import com.github.traderjoe95.mls.codec.type.derive
&nbsp;import com.github.traderjoe95.mls.codec.type.get
&nbsp;import com.github.traderjoe95.mls.codec.type.optional
&nbsp;import com.github.traderjoe95.mls.codec.util.uSize
&nbsp;import com.github.traderjoe95.mls.protocol.crypto.CipherSuite
&nbsp;import com.github.traderjoe95.mls.protocol.error.VerifySignatureError
&nbsp;import com.github.traderjoe95.mls.protocol.group.GroupContext
&nbsp;import com.github.traderjoe95.mls.protocol.message.KeyPackage
&nbsp;import com.github.traderjoe95.mls.protocol.tree.PublicRatchetTree.Companion.encodeUnsafe
&nbsp;import com.github.traderjoe95.mls.protocol.tree.PublicRatchetTree.Companion.newTree
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.HpkeKeyPair
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.HpkePrivateKey
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Secret
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.SignaturePublicKey
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.FramedContent
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.KeyPackageLeafNode
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.LeafNode
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.Node
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.ParentNode
&nbsp;import com.github.traderjoe95.mls.protocol.util.get
&nbsp;import com.github.traderjoe95.mls.protocol.util.log2
&nbsp;import com.github.traderjoe95.mls.protocol.util.shl
&nbsp;import com.github.traderjoe95.mls.protocol.util.sliceArray
&nbsp;import com.github.traderjoe95.mls.protocol.util.uSize
&nbsp;import java.util.concurrent.ConcurrentHashMap
&nbsp;import java.util.concurrent.ConcurrentMap
&nbsp;
&nbsp;sealed interface RatchetTreeOps : SignaturePublicKeyLookup {
&nbsp;  val size: UInt
&nbsp;
&nbsp;  val root: NodeIndex
&nbsp;
&nbsp;  val indices: NodeRange
&nbsp;  val leafNodeIndices: NodeProgression
&nbsp;  val parentNodeIndices: NodeProgression
&nbsp;
&nbsp;  val leaves: List&lt;LeafNode&lt;*&gt;?&gt;
&nbsp;
&nbsp;  val firstBlankLeaf: LeafIndex?
&nbsp;
&nbsp;  val TreeIndex.isBlank: Boolean
&nbsp;
&nbsp;  operator fun get(nodeIndex: TreeIndex): Node?
&nbsp;
&nbsp;  operator fun get(nodeIndices: Iterable&lt;TreeIndex&gt;): List&lt;Node?&gt;
&nbsp;
&nbsp;  fun directPath(node: TreeIndex): List&lt;NodeIndex&gt;
&nbsp;
&nbsp;  fun coPath(node: TreeIndex): List&lt;NodeIndex&gt;
&nbsp;
&nbsp;  fun filteredDirectPath(node: TreeIndex): List&lt;Pair&lt;NodeIndex, List&lt;NodeIndex&gt;&gt;&gt;
&nbsp;
&nbsp;  fun resolution(node: TreeIndex): List&lt;NodeIndex&gt;
&nbsp;
&nbsp;  fun node(idx: TreeIndex): Node
&nbsp;
&nbsp;  fun parentNode(idx: NodeIndex): ParentNode
&nbsp;
&nbsp;  fun leafNode(idx: TreeIndex): LeafNode&lt;*&gt;
&nbsp;
&nbsp;  fun leafNodeOrNull(idx: TreeIndex): LeafNode&lt;*&gt;?
&nbsp;
&nbsp;  context(Raise&lt;VerifySignatureError.SignaturePublicKeyKeyNotFound&gt;)
&nbsp;  override fun getSignaturePublicKey(
&nbsp;    groupContext: GroupContext,
&nbsp;    framedContent: FramedContent&lt;*&gt;,
&nbsp;  ): SignaturePublicKey = findSignaturePublicKey(framedContent, groupContext, this)
&nbsp;}
&nbsp;
&nbsp;class RatchetTree(
&nbsp;  val cipherSuite: CipherSuite,
&nbsp;  internal val public: PublicRatchetTree,
&nbsp;  internal val private: PrivateRatchetTree,
&nbsp;) : RatchetTreeOps by public {
&nbsp;  val leafIndex: LeafIndex
&nbsp;    get() = private.leafIndex
&nbsp;
&nbsp;  val encoded: ByteArray by lazy { public.encodeUnsafe() }
&nbsp;
&nbsp;  fun insert(newLeaf: LeafNode&lt;*&gt;): Pair&lt;RatchetTree, LeafIndex&gt; =
&nbsp;    public.insert(newLeaf).let { (newPublic, newLeaf) -&gt;
&nbsp;      RatchetTree(cipherSuite, newPublic, private) to newLeaf
&nbsp;    }
&nbsp;
&nbsp;  fun update(
&nbsp;    leafIndex: LeafIndex,
&nbsp;    leafNode: LeafNode&lt;*&gt;,
&nbsp;  ): RatchetTree =
&nbsp;    RatchetTree(
&nbsp;      cipherSuite,
&nbsp;      public.update(leafIndex, leafNode),
&nbsp;      private.blank(directPath(leafIndex)),
&nbsp;    )
&nbsp;
&nbsp;  fun update(
&nbsp;    leafIndex: LeafIndex,
&nbsp;    leafNode: LeafNode&lt;*&gt;,
&nbsp;    privateKey: HpkePrivateKey,
&nbsp;  ): RatchetTree =
&nbsp;    RatchetTree(
&nbsp;      cipherSuite,
&nbsp;      public.update(leafIndex, leafNode),
&nbsp;      private.blank(directPath(leafIndex)).add(leafIndex, privateKey),
&nbsp;    )
&nbsp;
&nbsp;  fun remove(leafIndex: LeafIndex): RatchetTree =
&nbsp;    (public.remove(leafIndex)).let { newPublic -&gt;
&nbsp;      RatchetTree(
&nbsp;        cipherSuite,
&nbsp;        newPublic,
&nbsp;        private.truncateToSize(newPublic.size),
&nbsp;      )
&nbsp;    }
&nbsp;
&nbsp;  fun remove(leafIndices: List&lt;LeafIndex&gt;): RatchetTree =
&nbsp;    (public.remove(leafIndices)).let { newPublic -&gt;
&nbsp;      RatchetTree(
&nbsp;        cipherSuite,
&nbsp;        newPublic,
&nbsp;        private.truncateToSize(newPublic.size),
&nbsp;      )
&nbsp;    }
&nbsp;
&nbsp;  fun blank(indices: Iterable&lt;TreeIndex&gt;): RatchetTree = RatchetTree(cipherSuite, public.blank(indices), private.blank(indices))
&nbsp;
&nbsp;  fun set(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    node: Node?,
&nbsp;  ): RatchetTree =
&nbsp;    RatchetTree(
&nbsp;      cipherSuite,
&nbsp;      public.set(nodeIndex, node),
&nbsp;      if (public[nodeIndex]?.encryptionKey != node?.encryptionKey) {
&nbsp;        private.blank(nodeIndex)
&nbsp;      } else {
&nbsp;        private
&nbsp;      },
&nbsp;    )
&nbsp;
&nbsp;  fun set(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    node: Node,
&nbsp;    privateEncryptionKey: HpkePrivateKey,
&nbsp;  ): RatchetTree =
&nbsp;    RatchetTree(
&nbsp;      cipherSuite,
&nbsp;      public.set(nodeIndex, node),
&nbsp;      private.add(nodeIndex, privateEncryptionKey),
&nbsp;    )
&nbsp;
&nbsp;  fun set(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    node: Node,
&nbsp;    pathSecret: Secret,
&nbsp;  ): RatchetTree =
&nbsp;    RatchetTree(
&nbsp;      cipherSuite,
&nbsp;      public.set(nodeIndex, node),
&nbsp;      private.add(nodeIndex, pathSecret),
&nbsp;    )
&nbsp;
&nbsp;  fun insertPathSecrets(
&nbsp;    from: TreeIndex,
&nbsp;    pathSecret: Secret,
&nbsp;  ): RatchetTree =
&nbsp;    RatchetTree(
&nbsp;      cipherSuite,
&nbsp;      public,
&nbsp;      private.insertPathSecrets(public, from, pathSecret),
&nbsp;    )
&nbsp;
&nbsp;  fun set(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    privateKey: HpkePrivateKey,
&nbsp;  ): RatchetTree =
&nbsp;    RatchetTree(
&nbsp;      cipherSuite,
&nbsp;      public,
&nbsp;      private.add(nodeIndex, privateKey),
&nbsp;    )
&nbsp;
&nbsp;  inline fun update(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    update: Node?.() -&gt; Node?,
&nbsp;  ): RatchetTree = set(nodeIndex, this[nodeIndex].update())
&nbsp;
&nbsp;  inline fun updateOrNull(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    update: Node.() -&gt; Node?,
&nbsp;  ): RatchetTree = update(nodeIndex) { this?.update() }
&nbsp;
&nbsp;  fun getPrivateKey(nodeIndex: TreeIndex): HpkePrivateKey? = private.getPrivateKey(nodeIndex)
&nbsp;
&nbsp;  fun getKeyPair(nodeIndex: TreeIndex): HpkeKeyPair? = getPrivateKey(nodeIndex)?.let { HpkeKeyPair(it, node(nodeIndex).encryptionKey) }
&nbsp;
&nbsp;  internal fun removeLeaves(leaves: Set&lt;LeafIndex&gt;): RatchetTree =
&nbsp;    if (leaves.isEmpty()) {
&nbsp;      this
&nbsp;    } else {
&nbsp;      RatchetTree(
&nbsp;        cipherSuite,
&nbsp;        public.removeLeaves(leaves),
&nbsp;        private.blank(leaves),
&nbsp;      )
&nbsp;    }
&nbsp;
&nbsp;  companion object {
&nbsp;    fun new(keyPackage: KeyPackage.Private): RatchetTree =
&nbsp;      RatchetTree(
&nbsp;        keyPackage.cipherSuite,
&nbsp;        keyPackage.leafNode.newTree(),
&nbsp;        PrivateRatchetTree(
&nbsp;          keyPackage.cipherSuite,
&nbsp;          LeafIndex(0U),
&nbsp;          mapOf(),
&nbsp;          mapOf(NodeIndex(0U) to keyPackage.encPrivateKey).toMap(ConcurrentHashMap()),
&nbsp;        ),
&nbsp;      )
&nbsp;
&nbsp;    fun new(
&nbsp;      cipherSuite: CipherSuite,
&nbsp;      leafNode: KeyPackageLeafNode,
&nbsp;      decryptionKey: HpkePrivateKey,
&nbsp;    ): RatchetTree =
&nbsp;      RatchetTree(
&nbsp;        cipherSuite,
&nbsp;        leafNode.newTree(),
&nbsp;        PrivateRatchetTree(
&nbsp;          cipherSuite,
&nbsp;          LeafIndex(0U),
&nbsp;          mapOf(),
&nbsp;          mapOf(NodeIndex(0U) to decryptionKey).toMap(ConcurrentHashMap()),
&nbsp;        ),
&nbsp;      )
&nbsp;
&nbsp;    fun PublicRatchetTree.insert(
&nbsp;      cipherSuite: CipherSuite,
&nbsp;      ownLeafNode: KeyPackageLeafNode,
&nbsp;      decryptionKey: HpkePrivateKey,
&nbsp;    ): RatchetTree =
&nbsp;      insert(ownLeafNode).let { (newPublic, newLeaf) -&gt;
&nbsp;        RatchetTree(
&nbsp;          cipherSuite,
&nbsp;          newPublic,
&nbsp;          PrivateRatchetTree(
&nbsp;            cipherSuite,
&nbsp;            newLeaf,
&nbsp;            mapOf(),
&nbsp;            mapOf(newLeaf.nodeIndex to decryptionKey).toMap(ConcurrentHashMap()),
&nbsp;          ),
&nbsp;        )
&nbsp;      }
&nbsp;
&nbsp;    fun PublicRatchetTree.join(
&nbsp;      cipherSuite: CipherSuite,
&nbsp;      leafIndex: LeafIndex,
&nbsp;      decryptionKey: HpkePrivateKey,
&nbsp;    ): RatchetTree =
&nbsp;      RatchetTree(
&nbsp;        cipherSuite,
&nbsp;        this,
&nbsp;        PrivateRatchetTree(
&nbsp;          cipherSuite,
&nbsp;          leafIndex,
&nbsp;          mapOf(),
&nbsp;          mapOf(leafIndex.nodeIndex to decryptionKey).toMap(ConcurrentHashMap()),
&nbsp;        ),
&nbsp;      )
&nbsp;  }
&nbsp;}
&nbsp;
&nbsp;@JvmInline
&nbsp;value class PublicRatchetTree private constructor(private val nodes: Array&lt;Node?&gt;) : RatchetTreeOps {
&nbsp;  override val size: UInt
&nbsp;    get() = nodes.uSize
&nbsp;  override val root: NodeIndex
&nbsp;    get() = NodeIndex.root(size)
&nbsp;
&nbsp;  override val indices: NodeRange
&nbsp;    get() = NodeIndex(0U)..&lt;size
&nbsp;  override val leafNodeIndices: NodeProgression
&nbsp;    get() = indices step 2
&nbsp;  override val parentNodeIndices: NodeProgression
&nbsp;    get() = NodeIndex(1U)..&lt;size step 2
&nbsp;
&nbsp;  @Suppress(&quot;UNCHECKED_CAST&quot;, &quot;kotlin:S6531&quot;)
&nbsp;  override val leaves: List&lt;LeafNode&lt;*&gt;?&gt;
&nbsp;    get() = this[leafNodeIndices] as List&lt;LeafNode&lt;*&gt;?&gt;
&nbsp;
&nbsp;  override val firstBlankLeaf: LeafIndex?
&nbsp;    get() = leafNodeIndices.find { it.isBlank }?.leafIndex
&nbsp;
&nbsp;  fun insert(newLeaf: LeafNode&lt;*&gt;): Pair&lt;PublicRatchetTree, LeafIndex&gt; =
&nbsp;    firstBlankLeaf
&nbsp;      ?.let { insertAt(newLeaf, it) }
&nbsp;      ?: extend().insert(newLeaf)
&nbsp;
&nbsp;  internal fun insertAt(
&nbsp;    leafNode: LeafNode&lt;*&gt;,
&nbsp;    leafIndex: LeafIndex,
&nbsp;  ): Pair&lt;PublicRatchetTree, LeafIndex&gt; {
&nbsp;    val nodeIndex = leafIndex.nodeIndex
&nbsp;    val intermediateDirectPath = directPath(nodeIndex).dropLast(1).map { it.value.toInt() }.toSet()
&nbsp;
&nbsp;    return PublicRatchetTree(
&nbsp;      Array(nodes.size) {
&nbsp;        if (it.toUInt() == nodeIndex.value) {
&nbsp;          leafNode
&nbsp;        } else if (it in intermediateDirectPath) {
&nbsp;          nodes[it]?.asParent?.run { copy(unmergedLeaves = unmergedLeaves + leafIndex) }
&nbsp;        } else {
&nbsp;          nodes[it]
&nbsp;        }
&nbsp;      },
&nbsp;    ) to leafIndex
&nbsp;  }
&nbsp;
&nbsp;  fun remove(leafIndex: LeafIndex): PublicRatchetTree = remove(listOf(leafIndex))
&nbsp;
&nbsp;  fun remove(leafIndices: List&lt;LeafIndex&gt;): PublicRatchetTree {
&nbsp;    // The specification states that only the intermediate nodes along the path are to be blanked (commented line of
&nbsp;    // code). Still, other implementors, including the public test vectors, blank the entire direct path of the leaf.
&nbsp;    //
&nbsp;    // Anyway, this shouldn&#39;t make any substantial difference in practice, as a Remove proposal requires an update
&nbsp;    // path, which will always replace the root of the tree.
&nbsp;    //
&nbsp;    // val intermediateDirectPath = directPath(leafIndex).dropLast(1).map { it.value.toInt() }.toSet()
&nbsp;    val directPath = leafIndices.flatMap(::directPath).map { it.value.toInt() }.toSet()
&nbsp;    val nodeIndices = leafIndices.map { it.nodeIndex.value.toInt() }.toSet()
&nbsp;
&nbsp;    return PublicRatchetTree(
&nbsp;      Array(nodes.size) {
&nbsp;        if (it in nodeIndices || it in directPath) {
&nbsp;          null
&nbsp;        } else {
&nbsp;          nodes[it]
&nbsp;        }
&nbsp;      },
&nbsp;    ).truncateIfRequired()
&nbsp;  }
&nbsp;
&nbsp;  fun update(
&nbsp;    leafIndex: LeafIndex,
&nbsp;    leafNode: LeafNode&lt;*&gt;,
&nbsp;  ): PublicRatchetTree =
&nbsp;    set(leafIndex, leafNode)
&nbsp;      // The specification states that only the intermediate nodes along the path are to be blanked (commented line of
&nbsp;      // code). Still, other implementors, including the public test vectors, blank the entire direct path of the leaf.
&nbsp;      //
&nbsp;      // Anyway, this shouldn&#39;t make any substantial difference in practice, as an Update proposal requires an update
&nbsp;      // path, which will always replace the root of the tree.
&nbsp;      //
&nbsp;      // .blank(directPath(leafIndex).dropLast(1))
&nbsp;      .blank(directPath(leafIndex))
&nbsp;
&nbsp;  fun blank(indices: Iterable&lt;TreeIndex&gt;): PublicRatchetTree =
&nbsp;    indices.map { it.nodeIndex.value.toInt() }.toSet().let { blanked -&gt;
&nbsp;      PublicRatchetTree(Array(nodes.size) { if (it in blanked) null else nodes[it] })
&nbsp;    }
&nbsp;
&nbsp;  internal fun removeLeaves(leaves: Set&lt;LeafIndex&gt;): PublicRatchetTree {
&nbsp;    if (leaves.isEmpty()) return this
&nbsp;
&nbsp;    val removedLeafIndices = leaves.map { it.value }.toSet()
&nbsp;    val removedLeafNodeIndices = leaves.map { it.nodeIndex.value.toInt() }.toSet()
&nbsp;    val removedLeafParentNodes = leaves.flatMap(::directPath).map { it.value.toInt() }.toSet()
&nbsp;
&nbsp;    return PublicRatchetTree(
&nbsp;      Array(nodes.size) { idx -&gt;
&nbsp;        when (idx) {
&nbsp;          in removedLeafNodeIndices -&gt; null
&nbsp;          in removedLeafParentNodes -&gt;
&nbsp;            nodes[idx]?.asParent?.run {
&nbsp;              copy(unmergedLeaves = unmergedLeaves.filter { it.value !in removedLeafIndices })
&nbsp;            }
&nbsp;
&nbsp;          else -&gt; nodes[idx]
&nbsp;        }
&nbsp;      },
&nbsp;    )
&nbsp;  }
&nbsp;
&nbsp;  override val TreeIndex.isBlank: Boolean
&nbsp;    get() = nodeIndex &gt;= nodes.size.toUInt() || nodes[nodeIndex.value] == null
&nbsp;
&nbsp;  override operator fun get(nodeIndex: TreeIndex): Node? = nodes[nodeIndex.nodeIndex.value]
&nbsp;
&nbsp;  override operator fun get(nodeIndices: Iterable&lt;TreeIndex&gt;): List&lt;Node?&gt; = nodes[nodeIndices.map { it.nodeIndex.value }]
&nbsp;
&nbsp;  fun set(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    node: Node?,
&nbsp;  ): PublicRatchetTree =
&nbsp;    nodeIndex.nodeIndex.let { idx -&gt;
&nbsp;      PublicRatchetTree(Array(nodes.size) { if (it.toUInt() == idx.value) node else nodes[it] })
&nbsp;    }
&nbsp;
&nbsp;  private val leftSubtree: PublicRatchetTree
&nbsp;    get() = PublicRatchetTree(nodes.sliceArray(0U..&lt;root.value))
&nbsp;
&nbsp;  private fun extend(): PublicRatchetTree {
&nbsp;    return PublicRatchetTree(
&nbsp;      Array&lt;Node?&gt;(nodes.size * 2 + 1) { null }.also { nodes.copyInto(it, 0) },
&nbsp;    )
&nbsp;  }
&nbsp;
&nbsp;  private fun truncateIfRequired(): PublicRatchetTree =
&nbsp;    generateSequence(this) { it.leftSubtree }
&nbsp;      .dropWhile { ((it.root + 1U)..&lt;it.size).all { node -&gt; node.isBlank } }
&nbsp;      .first()
&nbsp;
&nbsp;  override fun directPath(node: TreeIndex): List&lt;NodeIndex&gt; =
&nbsp;    node.nodeIndex.let { nodeIdx -&gt;
&nbsp;      if (nodeIdx &gt;= size || nodeIdx == root) {
&nbsp;        emptyList()
&nbsp;      } else {
&nbsp;        var current = nodeIdx
&nbsp;        val path = mutableListOf&lt;NodeIndex&gt;()
&nbsp;
&nbsp;        while (current != root) {
&nbsp;          current = current.parent
&nbsp;          path.add(current)
&nbsp;        }
&nbsp;
&nbsp;        path.toList()
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;  override fun coPath(node: TreeIndex): List&lt;NodeIndex&gt; =
&nbsp;    node.nodeIndex.let { nodeIdx -&gt;
&nbsp;      nodeIdx.prependTo(directPath(nodeIdx))
&nbsp;        .dropLast(1)
&nbsp;        .map { it.sibling }
&nbsp;    }
&nbsp;
&nbsp;  override fun filteredDirectPath(node: TreeIndex): List&lt;Pair&lt;NodeIndex, List&lt;NodeIndex&gt;&gt;&gt; =
&nbsp;    node.nodeIndex.let { nodeIdx -&gt;
&nbsp;      directPath(nodeIdx).zip(coPath(nodeIdx).map(::resolution)).filterNot { (_, res) -&gt;
&nbsp;        res.isEmpty()
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;  override fun resolution(node: TreeIndex): List&lt;NodeIndex&gt; =
&nbsp;    node.nodeIndex.let { nodeIdx -&gt;
&nbsp;      if (nodeIdx &gt;= size) {
&nbsp;        emptyList()
&nbsp;      } else {
&nbsp;        val toResolve = mutableListOf(nodeIdx)
&nbsp;        val result = mutableListOf&lt;NodeIndex&gt;()
&nbsp;
&nbsp;        while (toResolve.isNotEmpty()) {
&nbsp;          val current = toResolve.removeAt(0)
&nbsp;
&nbsp;          when {
&nbsp;            current.isBlank &amp;&amp; current.isParent -&gt;
&nbsp;              toResolve.addAll(0, listOf(current.leftChild, current.rightChild))
&nbsp;
&nbsp;            !current.isBlank &amp;&amp; current.isLeaf -&gt;
&nbsp;              result.add(current)
&nbsp;
&nbsp;            !current.isBlank -&gt; result.addAll(current.prependTo(parentNode(current).unmergedLeaves.map { it.nodeIndex }))
&nbsp;          }
&nbsp;        }
&nbsp;
&nbsp;        result.toList()
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;  override fun node(idx: TreeIndex): Node = this[idx.nodeIndex]!!
&nbsp;
&nbsp;  override fun parentNode(idx: NodeIndex): ParentNode = this[idx]!!.asParent
&nbsp;
&nbsp;  override fun leafNode(idx: TreeIndex): LeafNode&lt;*&gt; = this[idx.nodeIndex]!!.asLeaf
&nbsp;
&nbsp;  override fun leafNodeOrNull(idx: TreeIndex): LeafNode&lt;*&gt;? = this[idx.nodeIndex]?.asLeaf
&nbsp;
&nbsp;  companion object : Encodable&lt;PublicRatchetTree&gt; {
&nbsp;    @Suppress(&quot;kotlin:S6531&quot;, &quot;ktlint:standard:property-naming&quot;)
&nbsp;    override val T: DataType&lt;PublicRatchetTree&gt; =
&nbsp;      optional[Node.T][V].derive(
&nbsp;        { nodes -&gt;
&nbsp;          if (nodes.last().isNone()) {
&nbsp;            raise(DecoderError.UnexpectedError(&quot;Last node of an encoded ratchet tree must not be blank&quot;))
&nbsp;          }
&nbsp;
&nbsp;          val d = log2(nodes.uSize)
&nbsp;          val synthesizeBlankNodes = (1U shl (d + 1U)) - nodes.uSize - 1U
&nbsp;
&nbsp;          PublicRatchetTree(
&nbsp;            nodes.map { it.getOrNull() }.toTypedArray() + Array&lt;Node?&gt;(synthesizeBlankNodes.toInt()) { null },
&nbsp;          )
&nbsp;        },
&nbsp;        { tree -&gt; tree.nodes.map(Option.Companion::fromNullable).dropLastWhile(Option&lt;Node&gt;::isNone) },
&nbsp;      )
&nbsp;
&nbsp;    fun LeafNode&lt;*&gt;.newTree(): PublicRatchetTree = PublicRatchetTree(arrayOf(this))
&nbsp;
&nbsp;    fun blankWithLeaves(leafCount: UInt): PublicRatchetTree {
&nbsp;      require(leafCount.toString(2).count { it == &#39;1&#39; } == 1) { &quot;Leaf count must be a power of 2&quot; }
&nbsp;
&nbsp;      return PublicRatchetTree(Array(2 * leafCount.toInt() - 1) { null })
&nbsp;    }
&nbsp;  }
&nbsp;}
&nbsp;
<b class="fc">&nbsp;data class PrivateRatchetTree(</b>
<b class="fc">&nbsp;  private val cipherSuite: CipherSuite,</b>
<b class="fc">&nbsp;  val leafIndex: LeafIndex,</b>
<b class="fc">&nbsp;  internal val pathSecrets: Map&lt;NodeIndex, Secret&gt;,</b>
<b class="fc">&nbsp;  internal val privateKeyCache: ConcurrentMap&lt;NodeIndex, HpkePrivateKey&gt; = ConcurrentHashMap(),</b>
<b class="fc">&nbsp;  internal val commitSecret: Secret = Secret.zeroes(0U),</b>
&nbsp;) {
&nbsp;  fun insertPathSecrets(
&nbsp;    pub: PublicRatchetTree,
&nbsp;    from: TreeIndex,
&nbsp;    pathSecret: Secret,
&nbsp;  ): PrivateRatchetTree {
<b class="fc">&nbsp;    val fdp = pub.filteredDirectPath(from).map { it.first }</b>
<b class="fc">&nbsp;    val newPathSecrets =</b>
<b class="fc">&nbsp;      generateSequence(pathSecret) { cipherSuite.deriveSecret(it, &quot;path&quot;) }</b>
<b class="fc">&nbsp;        .take(fdp.size + 1)</b>
<b class="fc">&nbsp;        .toList()</b>
&nbsp;
<b class="fc">&nbsp;    return copy(</b>
<b class="fc">&nbsp;      pathSecrets = pathSecrets + from.nodeIndex.prependTo(fdp).zip(newPathSecrets).toMap(),</b>
<b class="fc">&nbsp;      privateKeyCache = (privateKeyCache - fdp.toSet() - from.nodeIndex).toMap(ConcurrentHashMap()),</b>
<b class="fc">&nbsp;      commitSecret = cipherSuite.deriveSecret(newPathSecrets.last(), &quot;path&quot;),</b>
&nbsp;    )
&nbsp;  }
&nbsp;
&nbsp;  fun add(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    pathSecret: Secret,
&nbsp;  ): PrivateRatchetTree =
<b class="fc">&nbsp;    copy(</b>
<b class="fc">&nbsp;      pathSecrets = pathSecrets + (nodeIndex.nodeIndex to pathSecret),</b>
<b class="fc">&nbsp;      privateKeyCache = (privateKeyCache - nodeIndex.nodeIndex).toMap(ConcurrentHashMap()),</b>
&nbsp;    )
&nbsp;
&nbsp;  fun add(
&nbsp;    nodeIndex: TreeIndex,
&nbsp;    privateKey: HpkePrivateKey,
&nbsp;  ): PrivateRatchetTree =
<b class="fc">&nbsp;    copy(</b>
<b class="fc">&nbsp;      pathSecrets = pathSecrets - nodeIndex.nodeIndex,</b>
<b class="fc">&nbsp;      privateKeyCache = (privateKeyCache + (nodeIndex.nodeIndex to privateKey)).toMap(ConcurrentHashMap()),</b>
&nbsp;    )
&nbsp;
&nbsp;  fun blank(indices: Iterable&lt;TreeIndex&gt;) =
<b class="fc">&nbsp;    copy(</b>
<b class="fc">&nbsp;      pathSecrets = pathSecrets - indices.map { it.nodeIndex }.toSet(),</b>
<b class="fc">&nbsp;      privateKeyCache = (privateKeyCache - indices.map { it.nodeIndex }.toSet()).toMap(ConcurrentHashMap()),</b>
&nbsp;    )
&nbsp;
&nbsp;  fun blank(idx: TreeIndex) =
<b class="fc">&nbsp;    copy(</b>
<b class="fc">&nbsp;      pathSecrets = pathSecrets - idx.nodeIndex,</b>
<b class="fc">&nbsp;      privateKeyCache = (privateKeyCache - idx.nodeIndex).toMap(ConcurrentHashMap()),</b>
&nbsp;    )
&nbsp;
&nbsp;  fun truncateToSize(size: UInt): PrivateRatchetTree =
<b class="fc">&nbsp;    copy(</b>
<b class="fc">&nbsp;      pathSecrets = pathSecrets.filterKeys { it &lt; size },</b>
<b class="pc">&nbsp;      privateKeyCache = privateKeyCache.filterKeys { it &lt; size }.toMap(ConcurrentHashMap()),</b>
&nbsp;    )
&nbsp;
&nbsp;  fun getPrivateKey(nodeIndex: TreeIndex): HpkePrivateKey? =
<b class="fc">&nbsp;    privateKeyCache.computeIfAbsent(nodeIndex.nodeIndex) {</b>
<b class="fc">&nbsp;      pathSecrets[it]?.let { cipherSuite.deriveKeyPair(cipherSuite.deriveSecret(it, &quot;node&quot;)).private }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-25 13:33</div>
</div>
</body>
</html>
