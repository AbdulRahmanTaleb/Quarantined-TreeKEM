


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>protocol Coverage Report > TreeUpdateKt</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: protocol<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.github.traderjoe95.mls.protocol.tree</a>
</div>

<h1>Coverage Summary for Class: TreeUpdateKt (com.github.traderjoe95.mls.protocol.tree)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">TreeUpdateKt</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (18/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.6%
  </span>
  <span class="absValue">
    (105/111)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.6%
  </span>
  <span class="absValue">
    (687/767)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.github.traderjoe95.mls.protocol.tree
&nbsp;
&nbsp;import arrow.core.prependTo
&nbsp;import arrow.core.raise.Raise
&nbsp;import com.github.traderjoe95.mls.codec.util.uSize
&nbsp;import com.github.traderjoe95.mls.protocol.crypto.ICipherSuite
&nbsp;import com.github.traderjoe95.mls.protocol.error.HpkeDecryptError
&nbsp;import com.github.traderjoe95.mls.protocol.error.JoinError
&nbsp;import com.github.traderjoe95.mls.protocol.error.RecipientTreeUpdateError
&nbsp;import com.github.traderjoe95.mls.protocol.error.SenderTreeUpdateError
&nbsp;import com.github.traderjoe95.mls.protocol.error.WrongParentHash
&nbsp;import com.github.traderjoe95.mls.protocol.error.WrongUpdatePathLength
&nbsp;import com.github.traderjoe95.mls.protocol.group.GroupContext
&nbsp;import com.github.traderjoe95.mls.protocol.types.RefinedBytes.Companion.neqNullable
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Secret
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Secret.Companion.asSecret
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.SignaturePrivateKey
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.LeafNode
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.ParentNode
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.UpdatePath
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.UpdatePathNode
&nbsp;import com.github.traderjoe95.mls.protocol.util.foldWith
&nbsp;
&nbsp;context(Raise&lt;SenderTreeUpdateError&gt;)
&nbsp;internal fun createUpdatePath(
&nbsp;  originalTree: RatchetTree,
&nbsp;  excludeNewLeaves: Set&lt;LeafIndex&gt;,
&nbsp;  groupContext: GroupContext,
&nbsp;  signaturePrivateKey: SignaturePrivateKey,
&nbsp;): Triple&lt;RatchetTree, UpdatePath, List&lt;Secret&gt;&gt; =
<b class="fc">&nbsp;  createUpdatePath(originalTree, originalTree.leafIndex, excludeNewLeaves, groupContext, signaturePrivateKey)</b>
&nbsp;
&nbsp;context(Raise&lt;SenderTreeUpdateError&gt;)
&nbsp;internal fun createUpdatePath(
&nbsp;  originalTree: RatchetTree,
&nbsp;  from: LeafIndex,
&nbsp;  excludeNewLeaves: Set&lt;LeafIndex&gt;,
&nbsp;  groupContext: GroupContext,
&nbsp;  signaturePrivateKey: SignaturePrivateKey,
&nbsp;): Triple&lt;RatchetTree, UpdatePath, List&lt;Secret&gt;&gt; =
<b class="fc">&nbsp;  with(originalTree.cipherSuite) {</b>
<b class="fc">&nbsp;    val oldLeafNode = originalTree.leafNode(from)</b>
&nbsp;
<b class="fc">&nbsp;    val leafPathSecret = generateSecret(hashLen)</b>
<b class="fc">&nbsp;    val leafNodeSecret = deriveSecret(leafPathSecret, &quot;node&quot;)</b>
<b class="fc">&nbsp;    val leafKp = deriveKeyPair(leafNodeSecret)</b>
&nbsp;
<b class="fc">&nbsp;    val directPath = originalTree.directPath(from)</b>
<b class="fc">&nbsp;    val filteredDirectPath = originalTree.filteredDirectPath(from)</b>
&nbsp;
<b class="fc">&nbsp;    val pathSecrets = mutableListOf(leafPathSecret)</b>
&nbsp;
<b class="fc">&nbsp;    val updatedTreeWithoutLeaf =</b>
<b class="fc">&nbsp;      originalTree</b>
<b class="fc">&nbsp;        .blank(directPath)</b>
<b class="fc">&nbsp;        .foldWith(filteredDirectPath) { (nodeIdx, _) -&gt;</b>
<b class="fc">&nbsp;          val newPathSecret = deriveSecret(pathSecrets.last(), &quot;path&quot;).also(pathSecrets::add)</b>
<b class="fc">&nbsp;          val nodeSecret = deriveSecret(newPathSecret, &quot;node&quot;)</b>
<b class="fc">&nbsp;          val nodeKp = deriveKeyPair(nodeSecret)</b>
<b class="fc">&nbsp;          nodeSecret.wipe()</b>
&nbsp;
<b class="fc">&nbsp;          set(nodeIdx, ParentNode.new(nodeKp.public), newPathSecret)</b>
&nbsp;        }
<b class="fc">&nbsp;        .foldWith(</b>
<b class="fc">&nbsp;          from.nodeIndex.prependTo(filteredDirectPath.map { it.first }).zipWithNext().reversed(),</b>
<b class="fc">&nbsp;        ) { (nodeIdx, parent) -&gt;</b>
<b class="fc">&nbsp;          updateOrNull(nodeIdx) { withParentHash(parentHash = parentHash(cipherSuite, parent, from)) }</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;    val newLeafNode =</b>
<b class="fc">&nbsp;      LeafNode.commit(</b>
<b class="fc">&nbsp;        originalTree.cipherSuite,</b>
<b class="fc">&nbsp;        leafKp.public,</b>
<b class="fc">&nbsp;        oldLeafNode,</b>
<b class="fc">&nbsp;        updatedTreeWithoutLeaf.parentHash(</b>
<b class="fc">&nbsp;          originalTree.cipherSuite,</b>
<b class="fc">&nbsp;          filteredDirectPath.first().first,</b>
<b class="fc">&nbsp;          from,</b>
&nbsp;        ),
<b class="fc">&nbsp;        from,</b>
<b class="fc">&nbsp;        groupContext.groupId,</b>
<b class="fc">&nbsp;        signaturePrivateKey,</b>
<b class="fc">&nbsp;      ).bind()</b>
<b class="fc">&nbsp;    val updatedTree =</b>
<b class="fc">&nbsp;      updatedTreeWithoutLeaf.set(</b>
<b class="fc">&nbsp;        from,</b>
<b class="fc">&nbsp;        newLeafNode,</b>
<b class="fc">&nbsp;        leafKp.private,</b>
&nbsp;      )
&nbsp;
<b class="fc">&nbsp;    val provisionalGroupCtx = groupContext.provisional(updatedTree)</b>
<b class="fc">&nbsp;    val excludedNodeIndices = excludeNewLeaves.map { it.nodeIndex }.toSet()</b>
&nbsp;
<b class="fc">&nbsp;    val updatePathNodes =</b>
<b class="fc">&nbsp;      filteredDirectPath.zip(pathSecrets.drop(1)).map { (nodeAndRes, pathSecret) -&gt;</b>
<b class="fc">&nbsp;        val (nodeIdx, resolution) = nodeAndRes</b>
<b class="fc">&nbsp;        val encryptFor = resolution - excludedNodeIndices</b>
&nbsp;
<b class="fc">&nbsp;        UpdatePathNode(</b>
<b class="fc">&nbsp;          updatedTree.parentNode(nodeIdx).encryptionKey,</b>
<b class="fc">&nbsp;          encryptFor.map { idx -&gt;</b>
<b class="fc">&nbsp;            encryptWithLabel(</b>
<b class="fc">&nbsp;              originalTree.node(idx).encryptionKey,</b>
<b class="fc">&nbsp;              &quot;UpdatePathNode&quot;,</b>
<b class="fc">&nbsp;              provisionalGroupCtx.encoded,</b>
<b class="fc">&nbsp;              pathSecret.bytes,</b>
<b class="fc">&nbsp;            ).bind()</b>
&nbsp;          },
&nbsp;        )
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;    return Triple(</b>
<b class="fc">&nbsp;      updatedTree,</b>
<b class="fc">&nbsp;      UpdatePath(newLeafNode, updatePathNodes),</b>
<b class="fc">&nbsp;      pathSecrets.drop(1),</b>
&nbsp;    )
&nbsp;  }
&nbsp;
&nbsp;context(Raise&lt;RecipientTreeUpdateError&gt;)
&nbsp;internal fun applyUpdatePath(
&nbsp;  originalTree: RatchetTree,
&nbsp;  groupContext: GroupContext,
&nbsp;  fromLeafIndex: LeafIndex,
&nbsp;  updatePath: UpdatePath,
&nbsp;  excludeNewLeaves: Set&lt;LeafIndex&gt;,
&nbsp;): Pair&lt;RatchetTree, Secret&gt; {
<b class="fc">&nbsp;  var updatedTree = originalTree.mergeUpdatePath(fromLeafIndex, updatePath)</b>
&nbsp;
<b class="fc">&nbsp;  val provisionalGroupCtx = groupContext.provisional(updatedTree)</b>
&nbsp;
<b class="fc">&nbsp;  val excludedNodeIndices = excludeNewLeaves.map { it.nodeIndex }.toSet()</b>
<b class="fc">&nbsp;  val (commonAncestor, pathSecret) =</b>
<b class="fc">&nbsp;    updatedTree.extractCommonPathSecret(</b>
<b class="fc">&nbsp;      fromLeafIndex,</b>
<b class="fc">&nbsp;      updatePath,</b>
<b class="fc">&nbsp;      provisionalGroupCtx,</b>
<b class="fc">&nbsp;      excludedNodeIndices,</b>
&nbsp;    )
&nbsp;
<b class="fc">&nbsp;  updatedTree = updatedTree.insertPathSecrets(commonAncestor, pathSecret)</b>
&nbsp;
<b class="fc">&nbsp;  return updatedTree to updatedTree.private.commitSecret</b>
&nbsp;}
&nbsp;
&nbsp;context(Raise&lt;RecipientTreeUpdateError&gt;)
&nbsp;internal fun RatchetTree.applyUpdatePathExternalJoin(
&nbsp;  groupContext: GroupContext,
&nbsp;  updatePath: UpdatePath,
&nbsp;  excludeNewLeaves: Set&lt;LeafIndex&gt;,
&nbsp;): Pair&lt;RatchetTree, Secret&gt; =
<b class="nc">&nbsp;  insert(updatePath.leafNode).let { (tree, newLeaf) -&gt;</b>
<b class="nc">&nbsp;    applyUpdatePath(tree, groupContext, newLeaf, updatePath, excludeNewLeaves)</b>
&nbsp;  }
&nbsp;
&nbsp;context(Raise&lt;RecipientTreeUpdateError&gt;)
&nbsp;internal fun RatchetTree.mergeUpdatePath(
&nbsp;  fromLeafIdx: LeafIndex,
&nbsp;  updatePath: UpdatePath,
&nbsp;): RatchetTree {
<b class="fc">&nbsp;  val directPath = directPath(fromLeafIdx)</b>
<b class="fc">&nbsp;  val filteredDirectPath = filteredDirectPath(fromLeafIdx)</b>
&nbsp;
<b class="pc">&nbsp;  if (filteredDirectPath.uSize != updatePath.size) {</b>
<b class="nc">&nbsp;    raise(WrongUpdatePathLength(filteredDirectPath.uSize, updatePath.size))</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  return blank(directPath)</b>
<b class="fc">&nbsp;    .foldWith(filteredDirectPath.zip(updatePath.nodes)) { (nodeAndRes, updateNode) -&gt;</b>
<b class="fc">&nbsp;      set(nodeAndRes.first, ParentNode.new(updateNode.encryptionKey))</b>
&nbsp;    }
<b class="fc">&nbsp;    .foldWith(filteredDirectPath.map { it.first }.zipWithNext().reversed()) { (nodeIdx, parentIdx) -&gt;</b>
<b class="fc">&nbsp;      updateOrNull(nodeIdx) { withParentHash(parentHash = parentHash(cipherSuite, parentIdx, fromLeafIdx)) }</b>
&nbsp;    }
<b class="fc">&nbsp;    .let { updatedWithoutLeaf -&gt;</b>
<b class="fc">&nbsp;      val computedParentHash = updatedWithoutLeaf.parentHash(cipherSuite, filteredDirectPath.first().first, fromLeafIdx)</b>
&nbsp;
<b class="pc">&nbsp;      if (updatePath.leafNode.parentHash neqNullable computedParentHash) {</b>
<b class="nc">&nbsp;        raise(WrongParentHash(computedParentHash.bytes, updatePath.leafNode.parentHash!!.bytes))</b>
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;      updatedWithoutLeaf.set(fromLeafIdx, updatePath.leafNode)</b>
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;context(Raise&lt;HpkeDecryptError&gt;)
&nbsp;internal fun RatchetTree.extractCommonPathSecret(
&nbsp;  fromLeafIdx: LeafIndex,
&nbsp;  updatePath: UpdatePath,
&nbsp;  groupContext: GroupContext,
&nbsp;  excludeNewLeaves: Set&lt;NodeIndex&gt;,
&nbsp;): Pair&lt;NodeIndex, Secret&gt; {
<b class="fc">&nbsp;  val filteredDirectPath = filteredDirectPath(fromLeafIdx)</b>
&nbsp;
<b class="pc">&nbsp;  return filteredDirectPath.zip(updatePath.nodes)</b>
<b class="fc">&nbsp;    .dropWhile { (nodeAndRes, _) -&gt; !leafIndex.isInSubtreeOf(nodeAndRes.first) }</b>
<b class="fc">&nbsp;    .firstOrNull()</b>
<b class="pc">&nbsp;    ?.let { (nodeAndRes, updateNode) -&gt;</b>
<b class="fc">&nbsp;      val (nodeIdx, resolution) = nodeAndRes</b>
&nbsp;
<b class="fc">&nbsp;      val pathSecret =</b>
<b class="fc">&nbsp;        (resolution - excludeNewLeaves)</b>
<b class="fc">&nbsp;          .zip(updateNode.encryptedPathSecret)</b>
<b class="pc">&nbsp;          .firstNotNullOf { (node, ciphertext) -&gt; getKeyPair(node)?.let(ciphertext::to) }</b>
<b class="fc">&nbsp;          .let { (ciphertext, keyPair) -&gt;</b>
<b class="fc">&nbsp;            cipherSuite.decryptWithLabel(</b>
<b class="fc">&nbsp;              keyPair,</b>
<b class="fc">&nbsp;              &quot;UpdatePathNode&quot;,</b>
<b class="fc">&nbsp;              groupContext.encoded,</b>
<b class="fc">&nbsp;              ciphertext,</b>
<b class="fc">&nbsp;            ).bind().asSecret</b>
&nbsp;          }
&nbsp;
<b class="fc">&nbsp;      nodeIdx to pathSecret</b>
&nbsp;    }
<b class="nc">&nbsp;    ?: error(&quot;No ancestor of own leaf index found in filtered direct path of committer&quot;)</b>
&nbsp;}
&nbsp;
&nbsp;context(ICipherSuite, Raise&lt;JoinError&gt;)
&nbsp;internal fun RatchetTree.insertPathSecrets(
&nbsp;  ownLeafIdx: LeafIndex,
&nbsp;  senderLeafIdx: LeafIndex,
&nbsp;  pathSecret: Secret,
&nbsp;): RatchetTree {
<b class="fc">&nbsp;  return insertPathSecrets(</b>
<b class="pc">&nbsp;    filteredDirectPath(senderLeafIdx)</b>
<b class="fc">&nbsp;      .map { it.first }</b>
<b class="pc">&nbsp;      .find { ownLeafIdx.isInSubtreeOf(it) &amp;&amp; senderLeafIdx.isInSubtreeOf(it) }</b>
<b class="nc">&nbsp;      ?: error(&quot;No ancestor of own leaf index found in filtered direct path of sender&quot;),</b>
<b class="fc">&nbsp;    pathSecret,</b>
&nbsp;  )
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-25 13:33</div>
</div>
</body>
</html>
