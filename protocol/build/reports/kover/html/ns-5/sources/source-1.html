


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>protocol Coverage Report > CommitKt</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: protocol<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.github.traderjoe95.mls.protocol.group</a>
</div>

<h1>Coverage Summary for Class: CommitKt (com.github.traderjoe95.mls.protocol.group)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">CommitKt</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    32.2%
  </span>
  <span class="absValue">
    (38/118)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52%
  </span>
  <span class="absValue">
    (127/244)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48.9%
  </span>
  <span class="absValue">
    (863/1764)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CommitKt$prepareCommit$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CommitKt$processCommit$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CommitKt$processProposals$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CommitKt$processProposals$2$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommitKt$processProposals$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CommitKt$validateAndApply$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">CommitKt$WhenMappings</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (40/120)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52.4%
  </span>
  <span class="absValue">
    (129/246)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    49.4%
  </span>
  <span class="absValue">
    (881/1782)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.github.traderjoe95.mls.protocol.group
&nbsp;
&nbsp;import arrow.core.Either
&nbsp;import arrow.core.None
&nbsp;import arrow.core.Option
&nbsp;import arrow.core.getOrElse
&nbsp;import arrow.core.raise.Raise
&nbsp;import arrow.core.raise.either
&nbsp;import arrow.core.raise.nullable
&nbsp;import arrow.core.toOption
&nbsp;import com.github.traderjoe95.mls.protocol.crypto.CipherSuite.Companion.zeroesNh
&nbsp;import com.github.traderjoe95.mls.protocol.crypto.KeySchedule
&nbsp;import com.github.traderjoe95.mls.protocol.error.CommitError
&nbsp;import com.github.traderjoe95.mls.protocol.error.InvalidCommit
&nbsp;import com.github.traderjoe95.mls.protocol.error.RecipientCommitError
&nbsp;import com.github.traderjoe95.mls.protocol.error.RecipientTreeUpdateError
&nbsp;import com.github.traderjoe95.mls.protocol.error.RemoveValidationError
&nbsp;import com.github.traderjoe95.mls.protocol.error.RemovedFromGroup
&nbsp;import com.github.traderjoe95.mls.protocol.error.SenderCommitError
&nbsp;import com.github.traderjoe95.mls.protocol.message.GroupInfo
&nbsp;import com.github.traderjoe95.mls.protocol.message.GroupInfo.Companion.encodeUnsafe
&nbsp;import com.github.traderjoe95.mls.protocol.message.GroupSecrets
&nbsp;import com.github.traderjoe95.mls.protocol.message.KeyPackage
&nbsp;import com.github.traderjoe95.mls.protocol.message.MessageOptions
&nbsp;import com.github.traderjoe95.mls.protocol.message.MlsMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.UsePublicMessage
&nbsp;import com.github.traderjoe95.mls.protocol.message.Welcome
&nbsp;import com.github.traderjoe95.mls.protocol.psk.PreSharedKeyId
&nbsp;import com.github.traderjoe95.mls.protocol.psk.PskLookup
&nbsp;import com.github.traderjoe95.mls.protocol.psk.ResolvedPsk.Companion.updatePskSecret
&nbsp;import com.github.traderjoe95.mls.protocol.service.AuthenticationService
&nbsp;import com.github.traderjoe95.mls.protocol.tree.LeafIndex
&nbsp;import com.github.traderjoe95.mls.protocol.tree.RatchetTree
&nbsp;import com.github.traderjoe95.mls.protocol.tree.applyUpdatePath
&nbsp;import com.github.traderjoe95.mls.protocol.tree.applyUpdatePathExternalJoin
&nbsp;import com.github.traderjoe95.mls.protocol.tree.createUpdatePath
&nbsp;import com.github.traderjoe95.mls.protocol.tree.findEquivalentLeaf
&nbsp;import com.github.traderjoe95.mls.protocol.tree.validate
&nbsp;import com.github.traderjoe95.mls.protocol.types.Extension
&nbsp;import com.github.traderjoe95.mls.protocol.types.GroupContextExtension
&nbsp;import com.github.traderjoe95.mls.protocol.types.ProposalType
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Aad
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.Secret
&nbsp;import com.github.traderjoe95.mls.protocol.types.crypto.SignaturePrivateKey
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.Sender
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Add
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.AuthenticatedContent
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Commit
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.ExternalInit
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.GroupContextExtensions
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.PreSharedKey
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Proposal
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.ProposalOrRef
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.ReInit
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Remove
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.content.Update
&nbsp;import com.github.traderjoe95.mls.protocol.types.framing.enums.SenderType
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.UpdatePath
&nbsp;import com.github.traderjoe95.mls.protocol.types.tree.leaf.LeafNodeSource
&nbsp;import com.github.traderjoe95.mls.protocol.types.RatchetTree as RatchetTreeExt
&nbsp;
<b class="nc">&nbsp;suspend fun &lt;Identity : Any&gt; GroupState.Active.prepareCommit(</b>
&nbsp;  proposals: List&lt;ProposalOrRef&gt;,
&nbsp;  authenticationService: AuthenticationService&lt;Identity&gt;,
<b class="nc">&nbsp;  messageOptions: MessageOptions = UsePublicMessage,</b>
&nbsp;  authenticatedData: ByteArray = byteArrayOf(),
<b class="nc">&nbsp;  inReInit: Boolean = false,</b>
<b class="nc">&nbsp;  inBranch: Boolean = false,</b>
<b class="nc">&nbsp;  psks: PskLookup = this,</b>
<b class="nc">&nbsp;  inlineTree: Boolean = true,</b>
<b class="nc">&nbsp;  forcePath: Boolean = false,</b>
&nbsp;): Either&lt;SenderCommitError, PrepareCommitResult&gt; =
<b class="nc">&nbsp;  either {</b>
<b class="nc">&nbsp;    val proposalResult = processProposals(proposals, None, authenticationService, leafIndex, inReInit, inBranch, psks)</b>
&nbsp;
<b class="nc">&nbsp;    val (updatedTree, updatePath, pathSecrets) =</b>
<b class="nc">&nbsp;      if (proposalResult.updatePathRequired || forcePath) {</b>
<b class="nc">&nbsp;        createUpdatePath(</b>
<b class="nc">&nbsp;          (proposalResult.updatedTree ?: tree),</b>
<b class="nc">&nbsp;          proposalResult.newMemberLeafIndices(),</b>
<b class="nc">&nbsp;          groupContext.withExtensions((proposalResult as? ProcessProposalsResult.CommitByMember)?.extensions),</b>
<b class="nc">&nbsp;          signaturePrivateKey,</b>
&nbsp;        )
&nbsp;      } else {
<b class="nc">&nbsp;        Triple((proposalResult.updatedTree ?: tree), null, listOf())</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;    val commitSecret = nullable { deriveSecret(pathSecrets.lastOrNull().bind(), &quot;path&quot;) } ?: zeroesNh</b>
&nbsp;
<b class="nc">&nbsp;    val partialCommit =</b>
<b class="nc">&nbsp;      messages.createAuthenticatedContent(</b>
<b class="nc">&nbsp;        Commit(proposals, updatePath.toOption()),</b>
<b class="nc">&nbsp;        messageOptions,</b>
<b class="nc">&nbsp;        authenticatedData,</b>
&nbsp;      )
&nbsp;
<b class="nc">&nbsp;    val updatedGroupContext =</b>
<b class="nc">&nbsp;      groupContext.evolve(</b>
<b class="nc">&nbsp;        partialCommit.wireFormat,</b>
<b class="nc">&nbsp;        partialCommit.framedContent,</b>
<b class="nc">&nbsp;        partialCommit.signature,</b>
<b class="nc">&nbsp;        updatedTree,</b>
<b class="nc">&nbsp;        newExtensions = (proposalResult as? ProcessProposalsResult.CommitByMember)?.extensions,</b>
&nbsp;      )
&nbsp;
<b class="nc">&nbsp;    val (newKeySchedule, joinerSecret, welcomeSecret) =</b>
<b class="nc">&nbsp;      keySchedule.nextEpoch(</b>
<b class="nc">&nbsp;        commitSecret,</b>
<b class="nc">&nbsp;        updatedGroupContext,</b>
<b class="nc">&nbsp;        proposalResult.pskSecret,</b>
<b class="nc">&nbsp;        (proposalResult as? ProcessProposalsResult.ExternalJoin)?.externalInitSecret,</b>
&nbsp;      )
&nbsp;
<b class="nc">&nbsp;    val confirmationTag = mac(newKeySchedule.confirmationKey, updatedGroupContext.confirmedTranscriptHash)</b>
&nbsp;
<b class="nc">&nbsp;    val updatedGroupState =</b>
<b class="nc">&nbsp;      proposalResult.createNextEpochState(</b>
<b class="nc">&nbsp;        updatedGroupContext.withInterimTranscriptHash(</b>
<b class="nc">&nbsp;          newInterimTranscriptHash(</b>
<b class="nc">&nbsp;            cipherSuite,</b>
<b class="nc">&nbsp;            updatedGroupContext.confirmedTranscriptHash,</b>
<b class="nc">&nbsp;            confirmationTag,</b>
&nbsp;          ),
&nbsp;        ),
<b class="nc">&nbsp;        updatedTree,</b>
<b class="nc">&nbsp;        newKeySchedule,</b>
&nbsp;      )
<b class="nc">&nbsp;    val groupInfo =</b>
<b class="nc">&nbsp;      GroupInfo.create(</b>
<b class="nc">&nbsp;        updatedGroupContext,</b>
<b class="nc">&nbsp;        confirmationTag,</b>
<b class="nc">&nbsp;        listOfNotNull(</b>
<b class="nc">&nbsp;          RatchetTreeExt(updatedTree).takeIf { inlineTree },</b>
<b class="nc">&nbsp;          *Extension.grease(),</b>
&nbsp;        ),
<b class="nc">&nbsp;        leafIndex,</b>
<b class="nc">&nbsp;        signaturePrivateKey,</b>
<b class="nc">&nbsp;      ).bind()</b>
&nbsp;
<b class="nc">&nbsp;    PrepareCommitResult(</b>
<b class="nc">&nbsp;      updatedGroupState,</b>
<b class="nc">&nbsp;      messages.protectCommit(partialCommit, confirmationTag, messageOptions),</b>
<b class="nc">&nbsp;      proposalResult.welcomeTo</b>
<b class="nc">&nbsp;        ?.takeIf { it.isNotEmpty() }</b>
<b class="nc">&nbsp;        ?.let { newMembers -&gt;</b>
<b class="nc">&nbsp;          listOf(</b>
<b class="nc">&nbsp;            PrepareCommitResult.WelcomeMessage(</b>
<b class="nc">&nbsp;              newMembers.createWelcome(</b>
<b class="nc">&nbsp;                groupInfo,</b>
<b class="nc">&nbsp;                updatedTree,</b>
<b class="nc">&nbsp;                pathSecrets,</b>
<b class="nc">&nbsp;                welcomeSecret,</b>
<b class="nc">&nbsp;                joinerSecret,</b>
<b class="nc">&nbsp;                proposalResult.pskIds,</b>
&nbsp;              ),
<b class="nc">&nbsp;              newMembers.map { it.second },</b>
&nbsp;            ),
&nbsp;          )
<b class="nc">&nbsp;        } ?: listOf(),</b>
&nbsp;    )
&nbsp;  }
&nbsp;
&nbsp;suspend fun &lt;Identity : Any&gt; GroupState.Active.processCommit(
&nbsp;  authenticatedCommit: AuthenticatedContent&lt;Commit&gt;,
&nbsp;  authenticationService: AuthenticationService&lt;Identity&gt;,
<b class="nc">&nbsp;  psks: PskLookup = this,</b>
&nbsp;): Either&lt;RecipientCommitError, GroupState&gt; =
<b class="fc">&nbsp;  either {</b>
<b class="fc">&nbsp;    val commit = authenticatedCommit.framedContent</b>
<b class="fc">&nbsp;    val proposalResult = commit.content.validateAndApply(commit.sender, psks, authenticationService)</b>
<b class="fc">&nbsp;    val updatePath = commit.content.updatePath</b>
&nbsp;
<b class="pc">&nbsp;    val preTree = proposalResult.updatedTree ?: tree</b>
&nbsp;
<b class="fc">&nbsp;    with(preTree) {</b>
<b class="pc">&nbsp;      if (leafIndex.isBlank) raise(RemovedFromGroup)</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    val (updatedTree, commitSecret) =</b>
<b class="fc">&nbsp;      updatePath.map { path -&gt;</b>
<b class="fc">&nbsp;        preTree.applyCommitUpdatePath(</b>
<b class="pc">&nbsp;          groupContext.withExtensions((proposalResult as? ProcessProposalsResult.CommitByMember)?.extensions),</b>
<b class="fc">&nbsp;          path,</b>
<b class="fc">&nbsp;          commit.sender,</b>
<b class="fc">&nbsp;          proposalResult.newMemberLeafIndices(),</b>
&nbsp;        )
<b class="fc">&nbsp;      }.getOrElse { preTree to zeroesNh }</b>
&nbsp;
<b class="fc">&nbsp;    val updatedGroupContext =</b>
<b class="fc">&nbsp;      groupContext.evolve(</b>
<b class="fc">&nbsp;        authenticatedCommit.wireFormat,</b>
<b class="fc">&nbsp;        commit,</b>
<b class="fc">&nbsp;        authenticatedCommit.signature,</b>
<b class="fc">&nbsp;        updatedTree,</b>
<b class="pc">&nbsp;        newExtensions = (proposalResult as? ProcessProposalsResult.CommitByMember)?.extensions,</b>
&nbsp;      )
&nbsp;
<b class="fc">&nbsp;    val (newKeySchedule, _, _) =</b>
<b class="fc">&nbsp;      keySchedule.nextEpoch(</b>
<b class="fc">&nbsp;        commitSecret,</b>
<b class="fc">&nbsp;        updatedGroupContext,</b>
<b class="fc">&nbsp;        proposalResult.pskSecret,</b>
<b class="pc">&nbsp;        (proposalResult as? ProcessProposalsResult.ExternalJoin)?.externalInitSecret,</b>
&nbsp;      )
&nbsp;
<b class="fc">&nbsp;    verifyMac(</b>
<b class="fc">&nbsp;      newKeySchedule.confirmationKey,</b>
<b class="fc">&nbsp;      updatedGroupContext.confirmedTranscriptHash,</b>
<b class="fc">&nbsp;      authenticatedCommit.confirmationTag!!,</b>
&nbsp;    )
&nbsp;
<b class="fc">&nbsp;    proposalResult.createNextEpochState(</b>
<b class="fc">&nbsp;      updatedGroupContext.withInterimTranscriptHash(</b>
<b class="fc">&nbsp;        newInterimTranscriptHash(</b>
<b class="fc">&nbsp;          cipherSuite,</b>
<b class="fc">&nbsp;          updatedGroupContext.confirmedTranscriptHash,</b>
<b class="fc">&nbsp;          authenticatedCommit.confirmationTag,</b>
&nbsp;        ),
&nbsp;      ),
<b class="fc">&nbsp;      updatedTree,</b>
<b class="fc">&nbsp;      newKeySchedule,</b>
&nbsp;    )
&nbsp;  }
&nbsp;
&nbsp;context(GroupState.Active, Raise&lt;CommitError&gt;)
&nbsp;private suspend fun &lt;Identity : Any&gt; Commit.validateAndApply(
&nbsp;  sender: Sender,
&nbsp;  psks: PskLookup,
&nbsp;  authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;): ProcessProposalsResult =
<b class="fc">&nbsp;  processProposals(</b>
<b class="fc">&nbsp;    proposals,</b>
<b class="fc">&nbsp;    updatePath,</b>
<b class="fc">&nbsp;    authenticationService,</b>
<b class="pc">&nbsp;    when (sender.type) {</b>
<b class="fc">&nbsp;      SenderType.Member -&gt; sender.index!!</b>
<b class="nc">&nbsp;      SenderType.NewMemberCommit -&gt; null</b>
<b class="nc">&nbsp;      else -&gt; raise(InvalidCommit.BadCommitSender(sender.type))</b>
&nbsp;    },
<b class="fc">&nbsp;    inReInit = false,</b>
<b class="fc">&nbsp;    inBranch = false,</b>
<b class="fc">&nbsp;    psks,</b>
<b class="fc">&nbsp;  ).also { result -&gt;</b>
<b class="pc">&nbsp;    if (result.updatePathRequired &amp;&amp; updatePath.isNone()) raise(InvalidCommit.MissingUpdatePath)</b>
&nbsp;
<b class="fc">&nbsp;    updatePath.onSome {</b>
<b class="fc">&nbsp;      it.leafNode.validate(</b>
<b class="fc">&nbsp;        tree,</b>
<b class="fc">&nbsp;        groupContext,</b>
<b class="pc">&nbsp;        sender.index</b>
<b class="nc">&nbsp;          ?: tree.firstBlankLeaf</b>
<b class="nc">&nbsp;          ?: (tree.leafNodeIndices.last + 2U).leafIndex,</b>
<b class="fc">&nbsp;        LeafNodeSource.Commit,</b>
&nbsp;      )
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;  }</b>
&nbsp;
&nbsp;context(GroupState)
&nbsp;private fun ProcessProposalsResult.newMemberLeafIndices(): Set&lt;LeafIndex&gt; =
<b class="fc">&nbsp;  when (this) {</b>
<b class="pc">&nbsp;    is ProcessProposalsResult.CommitByMember -&gt; welcomeTo.map { it.first }.toSet()</b>
<b class="nc">&nbsp;    is ProcessProposalsResult.ExternalJoin -&gt; setOf(tree.firstBlankLeaf ?: (tree.leafNodeIndices.last + 2U).leafIndex)</b>
<b class="nc">&nbsp;    is ProcessProposalsResult.ReInitCommit -&gt; setOf()</b>
&nbsp;  }
&nbsp;
&nbsp;context(Raise&lt;RecipientTreeUpdateError&gt;)
&nbsp;private fun RatchetTree.applyCommitUpdatePath(
&nbsp;  groupContext: GroupContext,
&nbsp;  updatePath: UpdatePath,
&nbsp;  sender: Sender,
&nbsp;  excludeNewLeaves: Set&lt;LeafIndex&gt;,
&nbsp;): Pair&lt;RatchetTree, Secret&gt; =
<b class="pc">&nbsp;  if (sender.type == SenderType.Member) {</b>
<b class="fc">&nbsp;    applyUpdatePath(this, groupContext, sender.index!!, updatePath, excludeNewLeaves)</b>
&nbsp;  } else {
<b class="nc">&nbsp;    applyUpdatePathExternalJoin(groupContext, updatePath, excludeNewLeaves)</b>
&nbsp;  }
&nbsp;
&nbsp;context(GroupState.Active, Raise&lt;SenderCommitError&gt;)
&nbsp;private fun List&lt;Pair&lt;LeafIndex, KeyPackage&gt;&gt;.createWelcome(
&nbsp;  groupInfo: GroupInfo,
&nbsp;  newTree: RatchetTree,
&nbsp;  pathSecrets: List&lt;Secret&gt;,
&nbsp;  welcomeSecret: Secret,
&nbsp;  joinerSecret: Secret,
&nbsp;  pskIds: List&lt;PreSharedKeyId&gt;,
&nbsp;): MlsMessage&lt;Welcome&gt; {
<b class="nc">&nbsp;  val welcomeNonce = expandWithLabel(welcomeSecret, &quot;nonce&quot;, byteArrayOf(), nonceLen).asNonce</b>
<b class="nc">&nbsp;  val welcomeKey = expandWithLabel(welcomeSecret, &quot;key&quot;, byteArrayOf(), keyLen)</b>
&nbsp;
<b class="nc">&nbsp;  val encryptedGroupInfo = encryptAead(welcomeKey, welcomeNonce, Aad.empty, groupInfo.encodeUnsafe())</b>
&nbsp;
<b class="nc">&nbsp;  val filteredPath = newTree.filteredDirectPath(leafIndex).map { it.first }</b>
&nbsp;
<b class="nc">&nbsp;  val encryptedGroupSecrets =</b>
<b class="nc">&nbsp;    map { (newLeaf, keyPackage) -&gt;</b>
<b class="nc">&nbsp;      val commonAncestorIdx = filteredPath.indexOfFirst { newLeaf.isInSubtreeOf(it) }</b>
<b class="nc">&nbsp;      val pathSecret = pathSecrets.getOrNull(commonAncestorIdx).toOption()</b>
&nbsp;
<b class="nc">&nbsp;      GroupSecrets(joinerSecret, pathSecret, pskIds)</b>
<b class="nc">&nbsp;        .encrypt(cipherSuite, keyPackage, encryptedGroupInfo)</b>
<b class="nc">&nbsp;    }.bindAll()</b>
&nbsp;
<b class="nc">&nbsp;  return MlsMessage.welcome(</b>
<b class="nc">&nbsp;    groupContext.cipherSuite,</b>
<b class="nc">&nbsp;    encryptedGroupSecrets,</b>
<b class="nc">&nbsp;    encryptedGroupInfo,</b>
&nbsp;  )
&nbsp;}
&nbsp;
&nbsp;context(Raise&lt;CommitError&gt;)
&nbsp;private suspend fun &lt;Identity : Any&gt; GroupState.Active.processProposals(
&nbsp;  proposals: List&lt;ProposalOrRef&gt;,
&nbsp;  updatePath: Option&lt;UpdatePath&gt;,
&nbsp;  authenticationService: AuthenticationService&lt;Identity&gt;,
&nbsp;  committerLeafIdx: LeafIndex?,
<b class="nc">&nbsp;  inReInit: Boolean = false,</b>
<b class="nc">&nbsp;  inBranch: Boolean = false,</b>
&nbsp;  psks: PskLookup,
&nbsp;): ProcessProposalsResult {
<b class="fc">&nbsp;  val resolved: ResolvedProposals = mutableMapOf()</b>
&nbsp;
<b class="fc">&nbsp;  proposals.forEach { proposalOrRef -&gt;</b>
<b class="fc">&nbsp;    val (proposal, sender) =</b>
<b class="fc">&nbsp;      when (proposalOrRef) {</b>
<b class="fc">&nbsp;        is Proposal -&gt; proposalOrRef to committerLeafIdx</b>
&nbsp;
<b class="fc">&nbsp;        is Proposal.Ref -&gt;</b>
<b class="pc">&nbsp;          if (committerLeafIdx == null) {</b>
<b class="nc">&nbsp;            raise(InvalidCommit.NoProposalRefAllowed)</b>
&nbsp;          } else {
<b class="fc">&nbsp;            getStoredProposal(proposalOrRef).let { it.proposal to it.sender }</b>
&nbsp;          }
&nbsp;      }
&nbsp;
<b class="fc">&nbsp;    resolved.compute(proposal.type) { _, current -&gt; (current ?: listOf()) + (proposal to sender) }</b>
<b class="fc">&nbsp;  }</b>
&nbsp;
<b class="pc">&nbsp;  if (committerLeafIdx == null) {</b>
<b class="nc">&nbsp;    resolved.validateExternal()</b>
&nbsp;  } else {
<b class="fc">&nbsp;    resolved.validateMember(committerLeafIdx)</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  var requiresUpdatePath = proposals.isEmpty()</b>
<b class="fc">&nbsp;  var updatedTree = tree</b>
<b class="fc">&nbsp;  var extensions: List&lt;GroupContextExtension&lt;*&gt;&gt;? = null</b>
<b class="fc">&nbsp;  val welcomeTo = mutableListOf&lt;Pair&lt;LeafIndex, KeyPackage&gt;&gt;()</b>
&nbsp;
<b class="fc">&nbsp;  var pskSecret = zeroesNh</b>
<b class="fc">&nbsp;  var pskIndex = 0</b>
<b class="fc">&nbsp;  val pskCount = resolved[ProposalType.Psk]?.size ?: 0</b>
<b class="fc">&nbsp;  val pskIds = mutableListOf&lt;PreSharedKeyId&gt;()</b>
&nbsp;
<b class="fc">&nbsp;  var newSignaturePrivateKey: SignaturePrivateKey? = null</b>
&nbsp;
<b class="fc">&nbsp;  ProposalType.ORDER.asSequence()</b>
<b class="fc">&nbsp;    .flatMap { resolved.getAll&lt;Proposal&gt;(it).asSequence() }</b>
<b class="fc">&nbsp;    .forEach { (proposal, from) -&gt;</b>
<b class="fc">&nbsp;      when (proposal) {</b>
<b class="fc">&nbsp;        is GroupContextExtensions -&gt; {</b>
<b class="fc">&nbsp;          validations.validated(</b>
<b class="fc">&nbsp;            proposal,</b>
<b class="fc">&nbsp;            updatedTree,</b>
<b class="fc">&nbsp;            resolved.getAll&lt;Remove&gt;(ProposalType.Remove).map { it.first.removed }.toSet(),</b>
&nbsp;          )
&nbsp;
<b class="fc">&nbsp;          extensions = proposal.extensions</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        is Update -&gt; {</b>
<b class="fc">&nbsp;          validations.validated(proposal, from!!, updatedTree).bind()</b>
&nbsp;
<b class="fc">&nbsp;          val cached = cachedUpdate</b>
&nbsp;
<b class="fc">&nbsp;          updatedTree =</b>
<b class="fc">&nbsp;            when {</b>
<b class="pc">&nbsp;              from != leafIndex -&gt; updatedTree.update(from, proposal.leafNode)</b>
&nbsp;
<b class="nc">&nbsp;              cached != null &amp;&amp; proposal.leafNode == cached.leafNode -&gt; {</b>
<b class="nc">&nbsp;                newSignaturePrivateKey = cached.signaturePrivateKey</b>
<b class="nc">&nbsp;                updatedTree.update(from, proposal.leafNode, cached.encryptionPrivateKey)</b>
&nbsp;              }
&nbsp;
<b class="nc">&nbsp;              cached != null -&gt;</b>
<b class="nc">&nbsp;                raise(CommitError.CachedUpdateDoesNotMatch(cached.leafNode, proposal.leafNode))</b>
&nbsp;
<b class="nc">&nbsp;              else -&gt; raise(CommitError.CachedUpdateMissing)</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;          requiresUpdatePath = true</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        is Remove -&gt; {</b>
<b class="fc">&nbsp;          validations.validated(proposal, updatedTree).bind()</b>
&nbsp;
<b class="pc">&nbsp;          if (committerLeafIdx == null) {</b>
<b class="nc">&nbsp;            val expectedClient = updatePath.getOrNull()!!.leafNode.credential</b>
&nbsp;
<b class="nc">&nbsp;            if (!authenticationService.isSameClient(expectedClient, updatedTree.leafNode(proposal.removed).credential).bind()) {</b>
<b class="nc">&nbsp;              raise(RemoveValidationError.UnauthorizedExternalRemove(proposal.removed))</b>
&nbsp;            }
&nbsp;          }
&nbsp;
<b class="fc">&nbsp;          updatedTree = updatedTree.remove(proposal.removed)</b>
<b class="fc">&nbsp;          requiresUpdatePath = true</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        is Add -&gt; {</b>
<b class="fc">&nbsp;          validations.validated(proposal, updatedTree).bind()</b>
&nbsp;
<b class="fc">&nbsp;          with(authenticationService) { updatedTree.findEquivalentLeaf(proposal.keyPackage.leafNode) }</b>
<b class="pc">&nbsp;            ?.also { raise(InvalidCommit.AlreadyMember(proposal.keyPackage, it)) }</b>
&nbsp;
<b class="fc">&nbsp;          val (treeWithNewMember, newMemberLeaf) = updatedTree.insert(proposal.keyPackage.leafNode)</b>
&nbsp;
<b class="fc">&nbsp;          updatedTree = treeWithNewMember</b>
<b class="fc">&nbsp;          welcomeTo.add(newMemberLeaf to proposal.keyPackage)</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        is PreSharedKey -&gt; {</b>
<b class="pc">&nbsp;          val psk = validations.validated(proposal, psks, inReInit, inBranch).bind()!!</b>
&nbsp;
<b class="fc">&nbsp;          pskSecret = updatePskSecret(pskSecret, proposal.pskId, psk, pskIndex++, pskCount)</b>
<b class="fc">&nbsp;          pskIds.add(proposal.pskId)</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        is ExternalInit -&gt;</b>
<b class="nc">&nbsp;          return ProcessProposalsResult.ExternalJoin(</b>
<b class="nc">&nbsp;            externalInitSecret = export(proposal.kemOutput, deriveKeyPair(keySchedule.externalSecret), &quot;&quot;).bind(),</b>
<b class="nc">&nbsp;            pskSecret,</b>
<b class="nc">&nbsp;            updatedTree,</b>
&nbsp;          )
&nbsp;
<b class="nc">&nbsp;        is ReInit -&gt; {</b>
<b class="nc">&nbsp;          validations.validated(proposal).bind()</b>
&nbsp;
<b class="nc">&nbsp;          return ProcessProposalsResult.ReInitCommit(proposal, zeroesNh)</b>
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;  return ProcessProposalsResult.CommitByMember(</b>
<b class="fc">&nbsp;    requiresUpdatePath,</b>
<b class="fc">&nbsp;    updatedTree,</b>
<b class="fc">&nbsp;    extensions,</b>
<b class="fc">&nbsp;    pskSecret,</b>
<b class="fc">&nbsp;    pskIds,</b>
<b class="fc">&nbsp;    welcomeTo,</b>
<b class="fc">&nbsp;    newSignaturePrivateKey,</b>
&nbsp;  )
&nbsp;}
&nbsp;
&nbsp;internal sealed interface ProcessProposalsResult {
&nbsp;  val updatePathRequired: Boolean
&nbsp;
&nbsp;  val pskSecret: Secret
&nbsp;  val pskIds: List&lt;PreSharedKeyId&gt;
&nbsp;    get() = listOf()
&nbsp;
&nbsp;  val updatedTree: RatchetTree?
&nbsp;
&nbsp;  val welcomeTo: List&lt;Pair&lt;LeafIndex, KeyPackage&gt;&gt;?
&nbsp;    get() = null
&nbsp;
&nbsp;  context(GroupState.Active)
&nbsp;  fun createNextEpochState(
&nbsp;    groupContext: GroupContext,
&nbsp;    tree: RatchetTree,
&nbsp;    keySchedule: KeySchedule,
&nbsp;  ): GroupState = nextEpoch(groupContext, tree, keySchedule)
&nbsp;
&nbsp;  data class CommitByMember(
&nbsp;    override val updatePathRequired: Boolean,
&nbsp;    override val updatedTree: RatchetTree,
&nbsp;    val extensions: List&lt;GroupContextExtension&lt;*&gt;&gt;?,
&nbsp;    override val pskSecret: Secret,
&nbsp;    override val pskIds: List&lt;PreSharedKeyId&gt;,
&nbsp;    override val welcomeTo: List&lt;Pair&lt;LeafIndex, KeyPackage&gt;&gt;,
&nbsp;    val newSignaturePrivateKey: SignaturePrivateKey?,
&nbsp;  ) : ProcessProposalsResult {
&nbsp;    context(GroupState.Active)
&nbsp;    override fun createNextEpochState(
&nbsp;      groupContext: GroupContext,
&nbsp;      tree: RatchetTree,
&nbsp;      keySchedule: KeySchedule,
&nbsp;    ): GroupState = nextEpoch(groupContext, tree, keySchedule, newSignaturePrivateKey ?: signaturePrivateKey)
&nbsp;  }
&nbsp;
&nbsp;  data class ExternalJoin(
&nbsp;    val externalInitSecret: Secret,
&nbsp;    override val pskSecret: Secret,
&nbsp;    override val updatedTree: RatchetTree,
&nbsp;  ) : ProcessProposalsResult {
&nbsp;    override val updatePathRequired: Boolean = true
&nbsp;  }
&nbsp;
&nbsp;  data class ReInitCommit(
&nbsp;    val reInit: ReInit,
&nbsp;    override val pskSecret: Secret,
&nbsp;  ) : ProcessProposalsResult {
&nbsp;    override val updatePathRequired: Boolean = false
&nbsp;    override val updatedTree: RatchetTree? = null
&nbsp;
&nbsp;    context(GroupState.Active)
&nbsp;    override fun createNextEpochState(
&nbsp;      groupContext: GroupContext,
&nbsp;      tree: RatchetTree,
&nbsp;      keySchedule: KeySchedule,
&nbsp;    ): GroupState = suspend(groupContext, tree, keySchedule, reInit)
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-25 13:33</div>
</div>
</body>
</html>
